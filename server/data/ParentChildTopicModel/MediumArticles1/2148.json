{"name": "2148", "parent": "", "title": "Creating the Flexible Space with Image Pattern on\u00a0Android", "sentences": [{"5d38": "Creating the Flexible Space with Image Pattern on\u00a0Android"}, {"8ae5": "The Design support library for Android makes it easy to create great animations. Let\u2019s look at how to create an app with a collapsing Toolbar animation. It\u2019s know as Flexible Space with Image pattern, a popular scrolling technique."}, {"5b5f": "I didn\u2019t know this pattern actually had a name until Ian Lake happened to point it out for me."}, {"09d8": "Flexible Space with Image\u00a0Pattern"}, {"effa": "A scrolling technique that supports an image header with a scrollable view below it. Upon scrolling, the \u2018Flexible Space\u2019 (image header) gets tinted with a color. At the same time, it collapses into a Toolbar\u200a\u2014\u200aMaterial Design guidelines"}, {"610e": "This pattern is a popular scrolling technique. In familiar terms, you can see this in WhatsApp\u2019s contact detail screen."}, {"877d": "Here\u2019s the step-by-step screenshots of the Flexible Space animation. Should give you a clear picture of what\u2019s going on."}, {"010d": "Notice the Toolbar dynamically changes color, depending on the image. It takes on the most dominant color present in the image."}, {"5132": "We can do this with the Palette API, but more on that later."}, {"2e32": "You might immediately start to freak out with the amount of code it might take. But rest assured, there\u2019s no scary Java code to write. Most of it is XML, so cheers to that!"}, {"1fdd": "Getting Started"}, {"79e3": "Start by adding the Design Support Library to your app/build.gradle file."}, {"a631": "dependencies {     \u2026     compile 'com.android.support:design:25.0.2' }"}, {"ceea": "Layout Structure"}, {"205b": "As always, we\u2019ll get started with the XML first. Open your activity.xml layout."}, {"25ec": "Here\u2019s the layout skeleton."}, {"be7b": "<android.support.design.widget.CoordinatorLayout >"}, {"92a0": "    <android.support.design.widget.AppBarLayout >"}, {"c364": "        <android.support.design.widget.CollapsingToolbarLayout >"}, {"c7eb": "            <ImageView />"}, {"14c2": "            <android.support.v7.widget.Toolbar />"}, {"6f12": "        </android.support.design.widget.CollapsingToolbarLayout>    </android.support.design.widget.AppBarLayout>        <!-- Your scrollable content here -->"}, {"af55": "</android.support.design.widget.CoordinatorLayout>"}, {"dbdb": "Design Support UI\u00a0Widgets"}, {"14d1": "I understand if all these layouts might appear new to you. But you won\u2019t have to worry. I\u2019ll do my best to explain them, in the easiest way."}, {"f0d1": "1. CoordinatorLayout"}, {"657d": "A powerful FrameLayout that specifies behavior for child views for various interactions. It also allows anchoring of floating views in your layout."}, {"851b": "2. AppBarLayout"}, {"1a23": "It is a special kind of vertical LinearLayout. It helps respond to its children\u2019s scroll events (scroll gestures). Additionally, it\u2019s responsible for implementing many features of Material Design\u2019s AppBarLayout."}, {"480b": "But, there\u2019s one thing to note. Its usage relies on being a direct child within CoordinatorLayout. The layout skeleton above demonstrates this."}, {"d64a": "3. CollapsingToolbarLayout"}, {"94bf": "It is a Toolbar wrapper which makes the \u2018Flexible Space\u2019 pattern possible. It collapses the image header while decreasing the expanded title to a Toolbar title."}, {"1d7d": "What\u2019s left is the ImageView which holds our actual header\u2019s image and Toolbar which we\u2019re familiar with."}, {"bff8": "4. FloatingActionButton"}, {"f3ec": "I\u2019m sure you\u2019re familiar with what a Floating Action Button is, aren\u2019t you? Android gave it a thumbs up by giving us an official UI widget. It\u2019s a part of the Design Support Library."}, {"6ed3": "More on this later."}, {"e698": "Defining the XML\u00a0Layout"}, {"ece0": "Alright, with that out of the way lets get to the actual XML."}, {"6e27": "A word of caution. The layout below might look threatening in size!"}, {"830c": "This is not complex code. XML just tends to be a little verbose. But you\u2019re welcome to try replicating the Flexible Space scroll animation in Java. Then I\u2019m sure you\u2019d truly appreciate how easy the Design Support library is."}, {"cf81": "However, I have highlighted the essential lines you need to focus on."}, {"7be8": "What you need to know from this?"}, {"e8e5": "A Behavior implements one or more interactions that may include drags, swipes, flings, or any other gestures."}, {"16cf": "Here\u2019s what the Android Studio\u2019s Preview pane shows us."}, {"7af9": "Flexible Space with Image Pattern\u200a\u2014\u200aXML Layout\u00a0Preview"}, {"e19c": "But wait. Does the expanded title look clear enough to you? I\u2019m sure it\u2019s not."}, {"bc78": "Whenever you display a label (TextView) against a background image, use a \u2018scrim\u2018. It will help make the text more readable."}, {"2ea4": "TIP: Use a Scrim for clear, readable\u00a0text"}, {"b2d9": "A Scrim is a semi-transparent gradient layer that helps text appear more readable against backgrounds."}, {"f8a3": "Just below your ImageView, add a simple View with a gradient Drawable as background."}, {"55a0": "<View     android:layout_width=\"match_parent\"     android:layout_height=\"160dp\"     android:layout_gravity=\"bottom\"                   android:background=\"@drawable/scrim\"/>"}, {"32b7": "Here\u2019s the Drawable scrim."}, {"65e4": "<shape xmlns:android=\"http://schemas.android.com/apk/res/android\"       android:shape=\"rectangle\">    <gradient        android:angle=\"90\"        android:endColor=\"@android:color/transparent\"        android:startColor=\"#66000000\"/></shape>"}, {"bf22": "That\u2019s a gradient with 40% opacity black from the bottom, to transparent at the top. 66 is the HEX code for 40%."}, {"a842": "If you want to play around transparency in hex codes, this wonderful StackOverflow answer helps."}, {"0b0b": "How to make a background transparent 20% in androidYou can manage color opacity changing the first 2 characters in the color definition. This includes hex transparency values from 0 to 100%\u00a0\u2026stackoverflow.com"}, {"6677": "So with the gradient applied, see the difference for yourself."}, {"fd6a": "AppBar without and with\u00a0Scrim"}, {"200a": "While the difference is subtle, the right one\u2019s much better right? Additionally, you can apply another scrim for the Toolbar. It can help the back and overflow icons be more visible. I leave this as an exercise for you."}, {"4adb": "I\u2019ve already mentioned a hint above on parallax scroll. But there\u2019s more to it."}, {"2562": "Getting the Parallax scroll\u00a0right"}, {"fc30": "We can achieve parallax scrolling with ImageView by setting its layout_collapseMode to parallax."}, {"fe4e": "Parallax Scrolling involves the background moving at a slower rate to the foreground.\u200a\u2014\u200aCreativebloq.com"}, {"e20a": "Did you notice an extra collapse mode attribute for the Toolbar?"}, {"ac3e": "Yes, you must use this as well. Why? Because, while the ImageView should collapse, the Toolbar must persist on scrolling."}, {"b4c8": "Toolbar must use collapseMode:pin, because we want it to persist and remain on top, as the user scrolls down."}, {"ecc1": "Note that I haven\u2019t set any color for the Toolbar. The CollapsingToolbarLayout takes care of this. It dynamically picks up a color from our image and sets it to the Toolbar."}, {"9d92": "If you\u2019re interested in Parallax scrolling with Tabs instead, this one\u2019s for you."}, {"3590": "Parallax Scrolling Tabs with Android Design Support LibraryCreating a parallax scrolling effect involves using the Flexible Space with Image pattern, along with using a TabLayout in addition\u2026blog.iamsuleiman.com"}, {"48f6": "Floating Action\u00a0Button"}, {"6a1c": "Floating action buttons are used for a promoted\u00a0action"}, {"7ca0": "I\u2019ll stick to calling it FAB from now on. If you tried to create a FAB earlier, you\u2019d realize how hard it was."}, {"c5f2": "But with the Design Support Library, that\u2019s not the case anymore. The layout above shows, how easy it is!"}, {"5dfd": "Notice that I haven\u2019t explicitly defined a size for the FAB. By default, it takes its regular width and height of 56dp. But, you can define this by using the following attribute."}, {"e3e7": "app:fabSize=\"regular\""}, {"a81b": "Optionally, you can set the fabSize as mini, which is a miniature version of the FAB at 40dp in size."}, {"a74b": "Next in the layout, we align the FAB with AppBarLayout. We do this with the layout_anchor attribute."}, {"1aae": "<android.support.design.widget.FloatingActionButton        ...        app:layout_anchor=\"@+id/appbar\"        app:layout_anchorGravity=\"bottom|right|end\" />"}, {"3623": "That\u2019s a wrap for the XML part. The good news is, this XML is all that\u2019s required to trigger the Flexible Space scroll animation."}, {"53fe": "But wait! There\u2019s still one thing that seems a bit off. What about the FAB\u2019s action?"}, {"ae37": "After scrolling, the \u2018Add\u2019 action goes hidden. It becomes available, only when you scroll all the way to the top. This is a bit inconvenient isn\u2019t it? So let\u2019s fix that."}, {"4de4": "The Hidden\u00a0Action"}, {"b6c9": "Once the AppBar collapses, we need to show the FAB\u2019s action somewhere."}, {"7bb8": "Now I\u2019m not saying this is the recommended approach. But my suggestion is that once the FAB vanishes, we add the action to the Toolbar\u2019s menu."}, {"ce05": "Add FAB Menu Item to Toolbar after\u00a0collapse"}, {"2b0f": "To do this we\u2019ll need a listener first. We have to listen to AppBarLayout expand and collapse states. To be precise, we need AppBarLayout.OffsetChangedListener."}, {"19e7": "If the AppBarLayout\u2019s \u2018verticalOffset\u2019 is zero, then its fully expanded. So when the verticalOffset is almost equal to the fully expanded height, add the action to Toolbar\u2019s menu."}, {"7073": "First, let\u2019s look at how to set the listener."}, {"e9e3": "appBarLayout.addOnOffsetChangedListener(new AppBarLayout.OnOffsetChangedListener() {            @Override            public void onOffsetChanged(AppBarLayout appBarLayout, int verticalOffset) {                //  Vertical offset == 0 indicates appBar is fully  expanded.                if (Math.abs(verticalOffset) > 200) {                    appBarExpanded = false;                    invalidateOptionsMenu();                } else {                    appBarExpanded = true;                    invalidateOptionsMenu();                }            }        });"}, {"3f11": "Some key takeaway points from the above code snippet."}, {"808f": "Updating the Toolbar\u00a0Menu"}, {"9f7e": "invalidateOptionsMenu() helps update our Toolbar Menu. But we need to tell our Menu when to add and remove the extra Action."}, {"8009": "First, we need a reference for the existing Menu. You can get this from the onCreateOptionsMenu() method."}, {"1bac": "@Override  public boolean onCreateOptionsMenu(Menu menu) {      getMenuInflater().inflate(R.menu.menu_main, menu);      collapsedMenu = menu;      return true;  }"}, {"bdad": "collapsedMenu is a global variable of type Menu. It allows us to keep a copy of the original Menu."}, {"fb2e": "Next, we need to update our Menu. We\u2019re already calling invalidateOptionsMenu() in the scroll listener. This will trigger the onPrepareOptionsMenu() method. Hence, we\u2019ll add our dynamic Menu logic here."}, {"9aad": "@Override    public boolean onPrepareOptionsMenu(Menu menu) {        if (collapsedMenu != null                && (!appBarExpanded || collapsedMenu.size() != 1)) {            //collapsed            collapsedMenu.add(\"Add\")                    .setIcon(R.drawable.ic_action_add)                    .setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);        } else {            //expanded        }        return super.onPrepareOptionsMenu(collapsedMenu);    }"}, {"ea66": "You\u2019ll notice that I haven\u2019t done anything for the expanded state. We don\u2019t need to either. I\u2019ll tell you why."}, {"54f8": "After onPrepareOptionsMenu(), the onCreateOptionsMenu() is called. What do we need to do in the expanded state? The FAB becomes visible, which means we should hide the \u2018Add\u2019 action from Toolbar menu."}, {"294d": "onCreateOptionsMenu() inflates the original Menu again. So we don\u2019t have to worry about removing the action ourselves."}, {"6a76": "So now, when the FAB hides, its Action is added to Toolbar Menu. When the AppBarLayout collapses, the \u2018Add\u2019 action becomes visible in the Toolbar Menu."}, {"cb2f": "Now all that remains is to do the usual UI initialization in Java. So let\u2019s setup our Toolbar first. Then we\u2019ll call in the Palette API."}, {"67df": "Setting up the basic\u00a0UI"}, {"365c": "We need to initialize our Toolbar first and then the CollapsingToolbarLayout\u00a0. So open your Activity.java and type away. Or you can copy-paste this instead."}, {"f4ba": "toolbar = (Toolbar) findViewById(R.id.anim_toolbar);setSupportActionBar(toolbar);"}, {"f696": "collapsingToolbar = (CollapsingToolbarLayout)    findViewById(R.id.collapsing_toolbar);collapsingToolbar.setTitle(\"Suleiman Ali Shakir\");"}, {"1b7d": "ImageView header = (ImageView) findViewById(R.id.header);"}, {"99d8": "Now you might ask me, why I have set a title for CollapsingToolbarLayout, instead of Toolbar? That\u2019s a valid question."}, {"7a1e": "Take a look at the Flexible Space with Image scroll animation. Yes, the GIF which I shared at the beginning of this post. Notice there\u2019s an expanded title, which on scrolling, collapses into the Toolbar title."}, {"f769": "The CollapsingToolbarLayout handles this for us. Hence we set the title for that, instead of a Toolbar."}, {"0d37": "Additionally, the CollapsingToolbarLayout also handles tinting our Toolbar using the Palette API. So let\u2019s look at that next."}, {"d819": "Dynamic Colors with Palette\u00a0API"}, {"7ca6": "The palette API is a support library that extracts prominent colors from\u00a0images."}, {"85ac": "The Palette API offers several color options (variations). Here are the basic four:"}, {"9738": "Image credits: developer.android.com"}, {"9d4e": "To use the Palette library, we first need to add it to your project. So open up your app/build.gradle and add the following line."}, {"9459": "dependencies {    \u2026    compile 'com.android.support:palette-v7:25.0.2'}"}, {"e9d9": "Using the Palette\u00a0API"}, {"4cd4": "First, pass the \u2018header\u2019 ImageView\u2019s bitmap to the Palette API. Then the API will generate colors based on the header image, in an AsyncTask."}, {"2f23": "Once it completes, we can fetch a color we want and set it to CollapsingToolbarLayout. This, in turn, tints our Toolbar to our chosen color, when we scroll."}, {"8db5": "Let\u2019s look at some code."}, {"76ec": "Bitmap bitmap = BitmapFactory.decodeResource(getResources(),                R.drawable.header);        Palette.from(bitmap).generate(new Palette.PaletteAsyncListener() {            @Override            public void onGenerated(Palette palette) {                mutedColor = palette.getMutedColor(R.attr.colorPrimary);                collapsingToolbar.setContentScrimColor(mutedColor);            }        });"}, {"df28": "I am fetching my bitmap from my resources directory."}, {"d48a": "But, in a real-world scenario, you would be downloading the image from an URL. Then saving it as a bitmap and passing that to the Palette API."}, {"5185": "You can also increase the number of colors generated from the image. Or you can even retrieve the entire color swatch! If you\u2019re interested in playing around with the Palette API, Chris Banes\u2019 post is a great article."}, {"986f": "Toolbar Animation in\u00a0Action"}, {"e729": "Finally, we\u2019ve completed what\u2019s needed for the Toolbar animation. In fact, much more than what\u2019s required! So go ahead, run your app and watch the magic."}, {"a53d": "Toolbar animation output"}, {"8bac": "Notice the blue color the Toolbar takes after collapsing? That\u2019s the \u2018mutedColor\u2019 generated from the image, by the Palette API."}, {"c229": "To be honest, it was surprising to see such a smooth Toolbar animation. Even the FAB beautifully reacts upon touch with a higher elevation."}, {"d3fb": "Source Code available on GitHub"}, {"34ec": "Suleiman19/Android-Material-Design-for-pre-LollipopAndroid-Material-Design-for-pre-Lollipop - Various UI implementations, animations & effects based on Material Design\u2026github.com"}, {"3cdd": "Material Design is a powerful visual language that can help you design a brilliant app."}, {"6ba4": "In Android, the Design Support Library makes it easy to create powerful animations, like this one. It allows us to create rich app experiences our users can enjoy."}, {"5958": "So how are you using the Design Support Library? Do you have your own take on the \u2018Flexible Space with Image\u2019 animation pattern? Let me know in the comments below."}, {"7aea": "Suleiman is an Android developer with an eye for design. He loves to design apps that people can use with ease. You can find him on his blog, LinkedIn or Twitter."}, {"5fbb": "Originally published at blog.iamsuleiman.com on June 2, 2015."}], "content": "Creating the Flexible Space with Image Pattern on\u00a0Android The Design support library for Android makes it easy to create great animations. Let\u2019s look at how to create an app with a collapsing Toolbar animation. It\u2019s know as Flexible Space with Image pattern, a popular scrolling technique. I didn\u2019t know this pattern actually had a name until Ian Lake happened to point it out for me. Flexible Space with Image\u00a0Pattern A scrolling technique that supports an image header with a scrollable view below it. Upon scrolling, the \u2018Flexible Space\u2019 (image header) gets tinted with a color. At the same time, it collapses into a Toolbar\u200a\u2014\u200aMaterial Design guidelines This pattern is a popular scrolling technique. In familiar terms, you can see this in WhatsApp\u2019s contact detail screen. Here\u2019s the step-by-step screenshots of the Flexible Space animation. Should give you a clear picture of what\u2019s going on. Notice the Toolbar dynamically changes color, depending on the image. It takes on the most dominant color present in the image. We can do this with the Palette API, but more on that later. You might immediately start to freak out with the amount of code it might take. But rest assured, there\u2019s no scary Java code to write. Most of it is XML, so cheers to that! Getting Started Start by adding the Design Support Library to your app/build.gradle file. dependencies {     \u2026     compile 'com.android.support:design:25.0.2' } Layout Structure As always, we\u2019ll get started with the XML first. Open your activity.xml layout. Here\u2019s the layout skeleton. <android.support.design.widget.CoordinatorLayout >     <android.support.design.widget.AppBarLayout >         <android.support.design.widget.CollapsingToolbarLayout >             <ImageView />             <android.support.v7.widget.Toolbar />         </android.support.design.widget.CollapsingToolbarLayout>    </android.support.design.widget.AppBarLayout>        <!-- Your scrollable content here --> </android.support.design.widget.CoordinatorLayout> Design Support UI\u00a0Widgets I understand if all these layouts might appear new to you. But you won\u2019t have to worry. I\u2019ll do my best to explain them, in the easiest way. 1. CoordinatorLayout A powerful FrameLayout that specifies behavior for child views for various interactions. It also allows anchoring of floating views in your layout. 2. AppBarLayout It is a special kind of vertical LinearLayout. It helps respond to its children\u2019s scroll events (scroll gestures). Additionally, it\u2019s responsible for implementing many features of Material Design\u2019s AppBarLayout. But, there\u2019s one thing to note. Its usage relies on being a direct child within CoordinatorLayout. The layout skeleton above demonstrates this. 3. CollapsingToolbarLayout It is a Toolbar wrapper which makes the \u2018Flexible Space\u2019 pattern possible. It collapses the image header while decreasing the expanded title to a Toolbar title. What\u2019s left is the ImageView which holds our actual header\u2019s image and Toolbar which we\u2019re familiar with. 4. FloatingActionButton I\u2019m sure you\u2019re familiar with what a Floating Action Button is, aren\u2019t you? Android gave it a thumbs up by giving us an official UI widget. It\u2019s a part of the Design Support Library. More on this later. Defining the XML\u00a0Layout Alright, with that out of the way lets get to the actual XML. A word of caution. The layout below might look threatening in size! This is not complex code. XML just tends to be a little verbose. But you\u2019re welcome to try replicating the Flexible Space scroll animation in Java. Then I\u2019m sure you\u2019d truly appreciate how easy the Design Support library is. However, I have highlighted the essential lines you need to focus on. What you need to know from this? A Behavior implements one or more interactions that may include drags, swipes, flings, or any other gestures. Here\u2019s what the Android Studio\u2019s Preview pane shows us. Flexible Space with Image Pattern\u200a\u2014\u200aXML Layout\u00a0Preview But wait. Does the expanded title look clear enough to you? I\u2019m sure it\u2019s not. Whenever you display a label (TextView) against a background image, use a \u2018scrim\u2018. It will help make the text more readable. TIP: Use a Scrim for clear, readable\u00a0text A Scrim is a semi-transparent gradient layer that helps text appear more readable against backgrounds. Just below your ImageView, add a simple View with a gradient Drawable as background. <View     android:layout_width=\"match_parent\"     android:layout_height=\"160dp\"     android:layout_gravity=\"bottom\"                   android:background=\"@drawable/scrim\"/> Here\u2019s the Drawable scrim. <shape xmlns:android=\"http://schemas.android.com/apk/res/android\"       android:shape=\"rectangle\">    <gradient        android:angle=\"90\"        android:endColor=\"@android:color/transparent\"        android:startColor=\"#66000000\"/></shape> That\u2019s a gradient with 40% opacity black from the bottom, to transparent at the top. 66 is the HEX code for 40%. If you want to play around transparency in hex codes, this wonderful StackOverflow answer helps. How to make a background transparent 20% in androidYou can manage color opacity changing the first 2 characters in the color definition. This includes hex transparency values from 0 to 100%\u00a0\u2026stackoverflow.com So with the gradient applied, see the difference for yourself. AppBar without and with\u00a0Scrim While the difference is subtle, the right one\u2019s much better right? Additionally, you can apply another scrim for the Toolbar. It can help the back and overflow icons be more visible. I leave this as an exercise for you. I\u2019ve already mentioned a hint above on parallax scroll. But there\u2019s more to it. Getting the Parallax scroll\u00a0right We can achieve parallax scrolling with ImageView by setting its layout_collapseMode to parallax. Parallax Scrolling involves the background moving at a slower rate to the foreground.\u200a\u2014\u200aCreativebloq.com Did you notice an extra collapse mode attribute for the Toolbar? Yes, you must use this as well. Why? Because, while the ImageView should collapse, the Toolbar must persist on scrolling. Toolbar must use collapseMode:pin, because we want it to persist and remain on top, as the user scrolls down. Note that I haven\u2019t set any color for the Toolbar. The CollapsingToolbarLayout takes care of this. It dynamically picks up a color from our image and sets it to the Toolbar. If you\u2019re interested in Parallax scrolling with Tabs instead, this one\u2019s for you. Parallax Scrolling Tabs with Android Design Support LibraryCreating a parallax scrolling effect involves using the Flexible Space with Image pattern, along with using a TabLayout in addition\u2026blog.iamsuleiman.com Floating Action\u00a0Button Floating action buttons are used for a promoted\u00a0action I\u2019ll stick to calling it FAB from now on. If you tried to create a FAB earlier, you\u2019d realize how hard it was. But with the Design Support Library, that\u2019s not the case anymore. The layout above shows, how easy it is! Notice that I haven\u2019t explicitly defined a size for the FAB. By default, it takes its regular width and height of 56dp. But, you can define this by using the following attribute. app:fabSize=\"regular\" Optionally, you can set the fabSize as mini, which is a miniature version of the FAB at 40dp in size. Next in the layout, we align the FAB with AppBarLayout. We do this with the layout_anchor attribute. <android.support.design.widget.FloatingActionButton        ...        app:layout_anchor=\"@+id/appbar\"        app:layout_anchorGravity=\"bottom|right|end\" /> That\u2019s a wrap for the XML part. The good news is, this XML is all that\u2019s required to trigger the Flexible Space scroll animation. But wait! There\u2019s still one thing that seems a bit off. What about the FAB\u2019s action? After scrolling, the \u2018Add\u2019 action goes hidden. It becomes available, only when you scroll all the way to the top. This is a bit inconvenient isn\u2019t it? So let\u2019s fix that. The Hidden\u00a0Action Once the AppBar collapses, we need to show the FAB\u2019s action somewhere. Now I\u2019m not saying this is the recommended approach. But my suggestion is that once the FAB vanishes, we add the action to the Toolbar\u2019s menu. Add FAB Menu Item to Toolbar after\u00a0collapse To do this we\u2019ll need a listener first. We have to listen to AppBarLayout expand and collapse states. To be precise, we need AppBarLayout.OffsetChangedListener. If the AppBarLayout\u2019s \u2018verticalOffset\u2019 is zero, then its fully expanded. So when the verticalOffset is almost equal to the fully expanded height, add the action to Toolbar\u2019s menu. First, let\u2019s look at how to set the listener. appBarLayout.addOnOffsetChangedListener(new AppBarLayout.OnOffsetChangedListener() {            @Override            public void onOffsetChanged(AppBarLayout appBarLayout, int verticalOffset) {                //  Vertical offset == 0 indicates appBar is fully  expanded.                if (Math.abs(verticalOffset) > 200) {                    appBarExpanded = false;                    invalidateOptionsMenu();                } else {                    appBarExpanded = true;                    invalidateOptionsMenu();                }            }        }); Some key takeaway points from the above code snippet. Updating the Toolbar\u00a0Menu invalidateOptionsMenu() helps update our Toolbar Menu. But we need to tell our Menu when to add and remove the extra Action. First, we need a reference for the existing Menu. You can get this from the onCreateOptionsMenu() method. @Override  public boolean onCreateOptionsMenu(Menu menu) {      getMenuInflater().inflate(R.menu.menu_main, menu);      collapsedMenu = menu;      return true;  } collapsedMenu is a global variable of type Menu. It allows us to keep a copy of the original Menu. Next, we need to update our Menu. We\u2019re already calling invalidateOptionsMenu() in the scroll listener. This will trigger the onPrepareOptionsMenu() method. Hence, we\u2019ll add our dynamic Menu logic here. @Override    public boolean onPrepareOptionsMenu(Menu menu) {        if (collapsedMenu != null                && (!appBarExpanded || collapsedMenu.size() != 1)) {            //collapsed            collapsedMenu.add(\"Add\")                    .setIcon(R.drawable.ic_action_add)                    .setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);        } else {            //expanded        }        return super.onPrepareOptionsMenu(collapsedMenu);    } You\u2019ll notice that I haven\u2019t done anything for the expanded state. We don\u2019t need to either. I\u2019ll tell you why. After onPrepareOptionsMenu(), the onCreateOptionsMenu() is called. What do we need to do in the expanded state? The FAB becomes visible, which means we should hide the \u2018Add\u2019 action from Toolbar menu. onCreateOptionsMenu() inflates the original Menu again. So we don\u2019t have to worry about removing the action ourselves. So now, when the FAB hides, its Action is added to Toolbar Menu. When the AppBarLayout collapses, the \u2018Add\u2019 action becomes visible in the Toolbar Menu. Now all that remains is to do the usual UI initialization in Java. So let\u2019s setup our Toolbar first. Then we\u2019ll call in the Palette API. Setting up the basic\u00a0UI We need to initialize our Toolbar first and then the CollapsingToolbarLayout\u00a0. So open your Activity.java and type away. Or you can copy-paste this instead. toolbar = (Toolbar) findViewById(R.id.anim_toolbar);setSupportActionBar(toolbar); collapsingToolbar = (CollapsingToolbarLayout)    findViewById(R.id.collapsing_toolbar);collapsingToolbar.setTitle(\"Suleiman Ali Shakir\"); ImageView header = (ImageView) findViewById(R.id.header); Now you might ask me, why I have set a title for CollapsingToolbarLayout, instead of Toolbar? That\u2019s a valid question. Take a look at the Flexible Space with Image scroll animation. Yes, the GIF which I shared at the beginning of this post. Notice there\u2019s an expanded title, which on scrolling, collapses into the Toolbar title. The CollapsingToolbarLayout handles this for us. Hence we set the title for that, instead of a Toolbar. Additionally, the CollapsingToolbarLayout also handles tinting our Toolbar using the Palette API. So let\u2019s look at that next. Dynamic Colors with Palette\u00a0API The palette API is a support library that extracts prominent colors from\u00a0images. The Palette API offers several color options (variations). Here are the basic four: Image credits: developer.android.com To use the Palette library, we first need to add it to your project. So open up your app/build.gradle and add the following line. dependencies {    \u2026    compile 'com.android.support:palette-v7:25.0.2'} Using the Palette\u00a0API First, pass the \u2018header\u2019 ImageView\u2019s bitmap to the Palette API. Then the API will generate colors based on the header image, in an AsyncTask. Once it completes, we can fetch a color we want and set it to CollapsingToolbarLayout. This, in turn, tints our Toolbar to our chosen color, when we scroll. Let\u2019s look at some code. Bitmap bitmap = BitmapFactory.decodeResource(getResources(),                R.drawable.header);        Palette.from(bitmap).generate(new Palette.PaletteAsyncListener() {            @Override            public void onGenerated(Palette palette) {                mutedColor = palette.getMutedColor(R.attr.colorPrimary);                collapsingToolbar.setContentScrimColor(mutedColor);            }        }); I am fetching my bitmap from my resources directory. But, in a real-world scenario, you would be downloading the image from an URL. Then saving it as a bitmap and passing that to the Palette API. You can also increase the number of colors generated from the image. Or you can even retrieve the entire color swatch! If you\u2019re interested in playing around with the Palette API, Chris Banes\u2019 post is a great article. Toolbar Animation in\u00a0Action Finally, we\u2019ve completed what\u2019s needed for the Toolbar animation. In fact, much more than what\u2019s required! So go ahead, run your app and watch the magic. Toolbar animation output Notice the blue color the Toolbar takes after collapsing? That\u2019s the \u2018mutedColor\u2019 generated from the image, by the Palette API. To be honest, it was surprising to see such a smooth Toolbar animation. Even the FAB beautifully reacts upon touch with a higher elevation. Source Code available on GitHub Suleiman19/Android-Material-Design-for-pre-LollipopAndroid-Material-Design-for-pre-Lollipop - Various UI implementations, animations & effects based on Material Design\u2026github.com Material Design is a powerful visual language that can help you design a brilliant app. In Android, the Design Support Library makes it easy to create powerful animations, like this one. It allows us to create rich app experiences our users can enjoy. So how are you using the Design Support Library? Do you have your own take on the \u2018Flexible Space with Image\u2019 animation pattern? Let me know in the comments below. Suleiman is an Android developer with an eye for design. He loves to design apps that people can use with ease. You can find him on his blog, LinkedIn or Twitter. Originally published at blog.iamsuleiman.com on June 2, 2015. ", "child": "2148_1\t2148_2\t2148_3\t2148_42148_1\t2148_2\t2148_3\t2148_42148_1\t2148_2\t2148_3\t2148_42148_1\t2148_2\t2148_3\t2148_42148_1\t2148_2\t2148_3\t2148_42148_1\t2148_2\t2148_3\t2148_42148_1\t2148_2\t2148_3\t2148_42148_1\t2148_2\t2148_3\t2148_4"}