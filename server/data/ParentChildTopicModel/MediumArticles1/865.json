{"name": "865", "parent": "", "title": "A Quick Look at Semaphores in Swift\u00a0\ud83d\udea6", "sentences": [{"bc9e": "A Quick Look at Semaphores in Swift\u00a0\ud83d\udea6"}, {"938a": "First of all, if you\u2019re not familiar with the Grand Central Dispatch (GCD) and Dispatch Queues, please head over this awesome article from AppCoda."}, {"b815": "All right! Time to talk about Semaphores!"}, {"532b": "Traffic Light by spaztacular"}, {"1f3f": "Introduction"}, {"fafe": "Let\u2019s imagine a group of writers that must share a single pen.\u00a0Obviously only one writer can use the pen at any given time."}, {"0284": "Now, imagine that those writers are our threads and that the pen is our shared resource (it can be anything: a file, a variable, the right to do something, etc)."}, {"6eda": "How do we make sure that our resource is really mutually exclusive?"}, {"49ee": "Streetless traffic light by Sylvain\u00a0Bourdos"}, {"669c": "Implementing our own Resource Control\u00a0Access"}, {"aa68": "Someone may think: well I can just use a resourceIsAvailable Bool and set it to true/false."}, {"2322": "The problem is that, on concurrency, there\u2019s no guarantee of knowing which thread, among all, is going to execute the next step, regardless of their priority."}, {"fa4e": "Example"}, {"81d7": "Imagine that we\u2019ve implemented the code above and that we have two threads, threadA and threadB, that would like to use a mutual exclusive resource:"}, {"9735": "Writing thread-safe code without GCD is not an easy task."}, {"f1ce": "At the lights by\u00a0petemc"}, {"59bf": "How Semaphores Work"}, {"cc86": "Three steps:"}, {"b8b7": "When this resource is only one and can be used only by one thread at any given time, you can think of these request/signal as the resource lock/unlock."}, {"18ef": "Robots/Traffic Light by\u00a0mallix"}, {"77cf": "What\u2019s Happening Behind the\u00a0Scenes"}, {"7522": "The Structure"}, {"2f31": "The Semaphore is composed by:"}, {"e499": "Resource Request:\u00a0wait()"}, {"608d": "When the semaphore receives a request, it checks if its counter is above zero:"}, {"b537": "Resource Release:\u00a0signal()"}, {"129c": "Once the semaphore receives a signal, it checks if its FIFO queue has threads in it:"}, {"944e": "Warning: Busy\u00a0Waiting"}, {"9776": "When a thread sends a wait() resource request to the semaphore, the thread freezes until the semaphore gives the thread the green light."}, {"b8e1": "\u26a0\ufe0f\ufe0f If you do this in the main thread, the whole app will freeze \u26a0\ufe0f\ufe0f"}, {"06af": "STOP Traffic Lights & Sunset by\u00a0eyecmore"}, {"84cc": "Using Semaphores in Swift (with\u00a0GCD)"}, {"a7bc": "Let\u2019s write some code!"}, {"1068": "Declaration"}, {"0bf5": "Declaring a Semaphore is simple:"}, {"8f65": "The value parameter is the number of threads that can access to the resource as for the semaphore creation."}, {"f2cf": "Resource Request"}, {"f710": "To request the semaphore\u2019s resource(s), we just call:"}, {"b76c": "Note that the semaphore is not physically giving us anything, the resource has to be in the thread\u2019s scope already, we just use the resource only between our request and release calls."}, {"b966": "Once the semaphore gives us its blessing, the thread resumes its normal execution and can consider the resource his to use."}, {"9c78": "Resource Release"}, {"2a5b": "To release the resource we write:"}, {"34be": "After sending this signal we aren\u2019t allowed to touch the resource anymore, until we request for it again."}, {"5898": "Semaphore Playgrounds"}, {"4cc8": "Following AppCoda article examples, let\u2019s see this Semaphore in action!"}, {"27cd": "Warning: these are Xcode Playgrounds, as Swift Playgrounds don\u2019t support Logging just yet. Fingers crossed for WWDC17!"}, {"dee6": "In these playgrounds we have two threads, one with slightly higher priority than the other, that print 10 times an emoji and incremental numbers."}, {"2f36": "Semaphore-less Playground"}, {"9691": "As you can Imagine, the higher priority thread finishes first most of the times:"}, {"9073": "Semaphore Playground"}, {"3e86": "In this case we will use the same code as before, but we will give the right to print the emoji+number sequence only to one thread at a time."}, {"cb86": "In order to do so we will define one semaphore and update our asyncPrint function:"}, {"cb05": "I\u2019ve also added a couple more print commands to see the actual state of each thread during our execution."}, {"6025": "As you can see, when one thread starts printing the sequence, the other thread must wait until the first one ends, then the semaphore will receive the signal from the first thread and then, only then, the second thread can start printing its own sequence."}, {"dd77": "It doesn\u2019t matter at which point of the sequence the second thread will send the wait() request, it will always have to wait until the other thread is done."}, {"ecf5": "Priority InversionNow that we understand how everything works, please take a look at the following log:"}, {"80b9": "In this case, with the exact code above, the processor has decided to execute the low priority thread first."}, {"73d3": "When this happens, the high priority thread must wait the low priority thread to finish! This is ok, it can happen.\u00a0The problem is that the low priority thread has low priority even when one high priority thread is waiting for him: this is called Priority Inversion."}, {"0ddd": "In other programming concepts different than the Semaphore, when this happens the low priority thread will temporarily inherit the priority of the highest priority thread that is waiting on him: this is called Priority Inheritance."}, {"05af": "With Semaphores this is not the case because, actually, anybody can call the signal() function (not only the thread that is currently using the resource)."}, {"f962": "Thread StarvationTo make things even worse, let\u2019s imagine that between our high & low priority threads there are 1000 more middle-priority threads."}, {"254c": "If we have a case of Priority Inversion like above, the high priority thread must wait for the low priority thread, but, most of the time, the processor will execute the middle priority threads, as they have higher priority than our low priority one."}, {"053e": "In this scenario our high priority thread is being starved of CPU time (hence the concept of Starvation)."}, {"f665": "Solutions"}, {"817e": "In my opinion, it\u2019s better to use Semaphores only among threads of the same priority. If this is not your case, I suggest you to look at other solutions such as Regions and Monitors."}, {"05b5": "Deadlock Playground"}, {"36e3": "This time we have two threads that use two mutual exclusive resources \u201cA\u201d and \u201cB\u201d."}, {"077f": "If the two resources can be used separately, it makes sense to define one semaphore for each resource. If not, one semaphore can manage both."}, {"1a0e": "I want to make an example with the former case (2 resources, 2 semaphores) with a twist: the high priority thread will use first resource \u201cA\u201d and then \u201cB\u201d, while our low priority one will use first resource \u201cB\u201d and then \u201cA\u201d."}, {"e168": "Here\u2019s the code:"}, {"8049": "If we\u2019re lucky, this is what happens:"}, {"2eba": "Simply, the high priority thread will be served with the first resource, then the second and only later the the processor will move to the low priority thread."}, {"dc3e": "However, if we\u2019re unlucky, this can also happen:"}, {"2eef": "Both threads didn\u2019t finish their execution! Let\u2019s review the current state:"}, {"a6b6": "Both threads are waiting on each other with no possibility to move forward: welcome to a Thread Deadlock!"}, {"7b9d": "Solutions"}, {"c924": "Avoiding deadlocks is not simple. The best solution would be preventing them by writing code that can\u2019t possibly reach this state."}, {"d7ba": "In other OSs, for example, one of the deadlock threads could be killed (in order to release all its resources) with the hope that other threads can continue their execution."}, {"6b51": "\u2026Or you can just use the Ostrich_Algorithm \ud83d\ude06."}, {"ef3c": "Let Me Keep My Memories by Thomas\u00a0Hawk"}, {"97c6": "Conclusions"}, {"995e": "Semaphores are a little nice concept that can be very handy in many applications. Just, be careful: look both ways before crossing."}, {"d66f": "Federico is a Bangkok-based Software Engineer with a strong passion for Swift, Minimalism, Design, and iOS Development."}], "content": "A Quick Look at Semaphores in Swift\u00a0\ud83d\udea6 First of all, if you\u2019re not familiar with the Grand Central Dispatch (GCD) and Dispatch Queues, please head over this awesome article from AppCoda. All right! Time to talk about Semaphores! Traffic Light by spaztacular Introduction Let\u2019s imagine a group of writers that must share a single pen.\u00a0Obviously only one writer can use the pen at any given time. Now, imagine that those writers are our threads and that the pen is our shared resource (it can be anything: a file, a variable, the right to do something, etc). How do we make sure that our resource is really mutually exclusive? Streetless traffic light by Sylvain\u00a0Bourdos Implementing our own Resource Control\u00a0Access Someone may think: well I can just use a resourceIsAvailable Bool and set it to true/false. The problem is that, on concurrency, there\u2019s no guarantee of knowing which thread, among all, is going to execute the next step, regardless of their priority. Example Imagine that we\u2019ve implemented the code above and that we have two threads, threadA and threadB, that would like to use a mutual exclusive resource: Writing thread-safe code without GCD is not an easy task. At the lights by\u00a0petemc How Semaphores Work Three steps: When this resource is only one and can be used only by one thread at any given time, you can think of these request/signal as the resource lock/unlock. Robots/Traffic Light by\u00a0mallix What\u2019s Happening Behind the\u00a0Scenes The Structure The Semaphore is composed by: Resource Request:\u00a0wait() When the semaphore receives a request, it checks if its counter is above zero: Resource Release:\u00a0signal() Once the semaphore receives a signal, it checks if its FIFO queue has threads in it: Warning: Busy\u00a0Waiting When a thread sends a wait() resource request to the semaphore, the thread freezes until the semaphore gives the thread the green light. \u26a0\ufe0f\ufe0f If you do this in the main thread, the whole app will freeze \u26a0\ufe0f\ufe0f STOP Traffic Lights & Sunset by\u00a0eyecmore Using Semaphores in Swift (with\u00a0GCD) Let\u2019s write some code! Declaration Declaring a Semaphore is simple: The value parameter is the number of threads that can access to the resource as for the semaphore creation. Resource Request To request the semaphore\u2019s resource(s), we just call: Note that the semaphore is not physically giving us anything, the resource has to be in the thread\u2019s scope already, we just use the resource only between our request and release calls. Once the semaphore gives us its blessing, the thread resumes its normal execution and can consider the resource his to use. Resource Release To release the resource we write: After sending this signal we aren\u2019t allowed to touch the resource anymore, until we request for it again. Semaphore Playgrounds Following AppCoda article examples, let\u2019s see this Semaphore in action! Warning: these are Xcode Playgrounds, as Swift Playgrounds don\u2019t support Logging just yet. Fingers crossed for WWDC17! In these playgrounds we have two threads, one with slightly higher priority than the other, that print 10 times an emoji and incremental numbers. Semaphore-less Playground As you can Imagine, the higher priority thread finishes first most of the times: Semaphore Playground In this case we will use the same code as before, but we will give the right to print the emoji+number sequence only to one thread at a time. In order to do so we will define one semaphore and update our asyncPrint function: I\u2019ve also added a couple more print commands to see the actual state of each thread during our execution. As you can see, when one thread starts printing the sequence, the other thread must wait until the first one ends, then the semaphore will receive the signal from the first thread and then, only then, the second thread can start printing its own sequence. It doesn\u2019t matter at which point of the sequence the second thread will send the wait() request, it will always have to wait until the other thread is done. Priority InversionNow that we understand how everything works, please take a look at the following log: In this case, with the exact code above, the processor has decided to execute the low priority thread first. When this happens, the high priority thread must wait the low priority thread to finish! This is ok, it can happen.\u00a0The problem is that the low priority thread has low priority even when one high priority thread is waiting for him: this is called Priority Inversion. In other programming concepts different than the Semaphore, when this happens the low priority thread will temporarily inherit the priority of the highest priority thread that is waiting on him: this is called Priority Inheritance. With Semaphores this is not the case because, actually, anybody can call the signal() function (not only the thread that is currently using the resource). Thread StarvationTo make things even worse, let\u2019s imagine that between our high & low priority threads there are 1000 more middle-priority threads. If we have a case of Priority Inversion like above, the high priority thread must wait for the low priority thread, but, most of the time, the processor will execute the middle priority threads, as they have higher priority than our low priority one. In this scenario our high priority thread is being starved of CPU time (hence the concept of Starvation). Solutions In my opinion, it\u2019s better to use Semaphores only among threads of the same priority. If this is not your case, I suggest you to look at other solutions such as Regions and Monitors. Deadlock Playground This time we have two threads that use two mutual exclusive resources \u201cA\u201d and \u201cB\u201d. If the two resources can be used separately, it makes sense to define one semaphore for each resource. If not, one semaphore can manage both. I want to make an example with the former case (2 resources, 2 semaphores) with a twist: the high priority thread will use first resource \u201cA\u201d and then \u201cB\u201d, while our low priority one will use first resource \u201cB\u201d and then \u201cA\u201d. Here\u2019s the code: If we\u2019re lucky, this is what happens: Simply, the high priority thread will be served with the first resource, then the second and only later the the processor will move to the low priority thread. However, if we\u2019re unlucky, this can also happen: Both threads didn\u2019t finish their execution! Let\u2019s review the current state: Both threads are waiting on each other with no possibility to move forward: welcome to a Thread Deadlock! Solutions Avoiding deadlocks is not simple. The best solution would be preventing them by writing code that can\u2019t possibly reach this state. In other OSs, for example, one of the deadlock threads could be killed (in order to release all its resources) with the hope that other threads can continue their execution. \u2026Or you can just use the Ostrich_Algorithm \ud83d\ude06. Let Me Keep My Memories by Thomas\u00a0Hawk Conclusions Semaphores are a little nice concept that can be very handy in many applications. Just, be careful: look both ways before crossing. Federico is a Bangkok-based Software Engineer with a strong passion for Swift, Minimalism, Design, and iOS Development. ", "child": "865_1\t865_2\t865_3\t865_4\t865_5\t865_6\t865_7\t865_8\t865_9\t865_10\t865_11865_1\t865_2\t865_3\t865_4\t865_5\t865_6\t865_7\t865_8\t865_9\t865_10\t865_11"}