{"name": "966", "parent": "", "title": "The Right Way to Test React Components", "sentences": [{"4cec": "The Right Way to Test React Components"}, {"f94d": "There\u2019s a lot of confusion right now about the \u201cright\u201d way to test your React components. Should you write all your tests by hand, or only use snapshots, or some of both? Should you test props? State? Styles/Layout?"}, {"5b26": "I don\u2019t think there\u2019s one \u201cright\u201d way, but I\u2019ve found a few patterns and tips that work really well for me that I\u2019d like to share."}, {"fada": "Background: The App We\u2019ll\u00a0Test"}, {"03b1": "Suppose you want to test a LockScreen component, which behaves like a phone\u2019s lock screen. It:"}, {"5126": "It looks something like this:"}, {"8577": "You can try it out here, and view the code on GitHub."}, {"c9f1": "Here\u2019s the code for the top-level App component:"}, {"64dd": "As you can see, LockScreen receives three props: wallpaperPath, userInfoMessage, and onUnlocked."}, {"f5d9": "Here\u2019s the code for LockScreen:"}, {"ebc5": "LockScreen pulls in a few other components, but since we\u2019re only testing LockScreen, let\u2019s focus on it right now."}, {"12e8": "Component Contracts"}, {"a451": "In order to test LockScreen, you must first understand what its Contract is. Understanding a component\u2019s contract is the most important part of testing a React component. A contract defines the expected behavior of your component and what assumptions are reasonable to have about its usage. Without a clear contract, your component may be hard to understand. Writing tests is a great way to formally define your component\u2019s contract."}, {"8ca1": "Every React component has at least one thing that contributes to the definition of its contract:"}, {"7a96": "Additionally, most component contracts are affected by these things as well:"}, {"c7a4": "Some less common things that affect component contracts are:"}, {"7a25": "To find your component\u2019s contract, ask yourself questions like:"}, {"e79b": "Finding LockScreen's Contract"}, {"40ae": "Let\u2019s go through LockScreen\u2019s render method and add comments at places where its behavior can differ. You\u2019ll look for ternaries, if statements, and switch statements as our clues. This will help us find variations in its contract."}, {"8011": "We\u2019ve learned three constraints that describe LockScreen's contract:"}, {"e8b3": "You can also find some constraints of the contract that are always true:"}, {"6478": "The component\u2019s propTypes are also a good place to look for clues about its contract. Here\u2019s some more constraints I notice:"}, {"6e54": "This is a good starting point for our component contract. There may be more constraints within this component\u2019s contract, and in production code you will want to find as many as you can, but for the purposes of this example, let\u2019s just work with these. You can always add tests later if you discover additional constraints."}, {"78fb": "What\u2019s Worth\u00a0Testing?"}, {"87c1": "Let\u2019s look over the contract we found:"}, {"dff4": "Some of these constraints are worth testing, and others are not. Here are three rules of thumb I use to determine that something is not worth testing:"}, {"0510": "These are only rules of thumb, so be careful not to use them to justify not testing something just because it\u2019s hard. Often, things that seem hard to test are the most important to test, because the code under test is making many assumptions about the rest of the application."}, {"c5ca": "Let\u2019s go through our constraints and use these rules of thumb to determine which need to be tested. Here\u2019s the first three:"}, {"0b4a": "These constraints are a concern of React\u2019s PropTypes mechanism, and so writing tests around prop types fails rule #2 (already covered by library code). As such, I don\u2019t test prop types. Because tests often double as documentation, I might decide to test something that failed rule #2 if the application code didn\u2019t document the expected types very well, but propTypes are already nice and human-readable."}, {"e967": "Here\u2019s the next constraint:"}, {"3b09": "This can be broken down into three constraints:"}, {"52a4": "The first two constraints that we broke this down into do not fail any of our rules of thumb, so we will test them. However, let\u2019s look at the third one."}, {"f055": "Ignoring the background-image property that is covered by another constraint, the wrapping div has these styles:"}, {"8159": "height: \"100%\",display: \"flex\",justifyContent: \"space-between\",flexDirection: \"column\",backgroundColor: \"black\",backgroundPosition: \"center\",backgroundSize: \"cover\","}, {"33c2": "If we wrote a test that these styles were on the div, we would have to test the value of each style exactly in order to make useful assertions. So our assertions might be something like:"}, {"1c97": "Even if we used something like toMatchObject to keep this test succinct, this would duplicate the same styles in the application code, and be brittle. If we added another style, we would have to put the exact same code in our test. If we tweaked a style, we would have to tweak it in our test, even though the component\u2019s behavior may not have changed. Therefore, this constraint fails rule #1 (duplicates application code; brittle). For this reason, I don\u2019t test inline styles, unless they can change at runtime."}, {"5480": "Often, if you are writing a test that amounts to \u201cit does what it does\u201d, or \u201cit does exactly this, which happens to be duplicated in the application code\u201d, then the test is either unnecessary or too broad."}, {"811b": "Here\u2019s the next two constraints:"}, {"d81e": "These can be broken down into:"}, {"d6a6": "These constraints fall into two categories: \u201cSome composite component is rendered\u201d, and \u201cthe rendered component receives these props\u201d. Both are very important to test, as they describe how your component interacts with other components. We will test all of these constraints."}, {"1f62": "The next constraint is:"}, {"7269": "You may think that, because this is an inline style, we do not need to test it. However, because the value of background-image can change based on the wallpaperPath prop, it needs to be tested. If we did not test it, then there would be no test around the effect of the wallpaperPath prop, which is part of the public interface of this component. You should always test your public interface."}, {"3a17": "The final two constraints are:"}, {"036d": "These can be broken down into:"}, {"978c": "The first and fourth constraints (a TopOverlay should/should not be rendered) describe what we render, so we will test them."}, {"df41": "The second constraint verifies that the TopOverlay receives a particular prop based on the value of userInfoMessage. It is important to write tests around the props that rendered components receive, so we will test it."}, {"479e": "The third constraint verifies that TopOverlay receives a particular prop, so you might think that we should test it. However, this prop is just some inline styles. Asserting that props are passed is important, but making assertions about inline styles is brittle and duplicates application code (fails rule #1). Because it\u2019s important to test passed props, it\u2019s not clear whether this should be tested just by looking at rule #1 alone; luckily, that\u2019s why I have rule #3. As a reminder, it\u2019s:"}, {"b20b": "From an outsider\u2019s perspective, is this detail important, or is it only an internal concern? Can the effect of this internal detail be described using only the component\u2019s public API?"}, {"02f3": "When I write component tests, I only test the public API of the component (including side effects that API has on the application) where possible. The exact layout of this component is not impacted by this component\u2019s public API; it is a concern of the CSS engine. Because of this, this constraint fails rule #3. Because it fails rule #1 and rule #3, we will not test this constraint, even though it verifies that TopOverlay receives a prop, which is normally important."}, {"694a": "It was hard to determine whether that final constraint should be tested or not. Ultimately, it is up to you to decide which parts are important to test; these rules of thumb I use are only guidelines."}, {"fa27": "Now we\u2019ve gone through all of our constraints, and know which ones we are going to write tests for. Here they are:"}, {"3261": "By examining our constraints and putting them to scrutiny, we broke many of them down into multiple, smaller constraints. This is great! This will make it easier to write our test code."}, {"df5e": "Setting Up Some Test Boilerplate"}, {"5c92": "Let\u2019s start scaffolding out a test for this component. I will be using Jest with enzyme in my tests. Jest works great with React and is also the test runner included in apps created with create-react-app, so you may already be set up to use it. Enzyme is a mature React testing library that works in both node and the browser."}, {"5779": "Even though I\u2019m using Jest and enzyme in my tests, you can apply the concepts here to almost any test configuration."}, {"1309": "This is a lot of boilerplate. Let me explain what I\u2019ve set up here:"}, {"7c3d": "This boilerplate may seem like a lot just to test a component, but it lets us build up our props incrementally before we mount our component, which will help keep our tests dry. I use it for all of my component tests, and I hope you will find it useful; its utility will become more apparent as we write the test cases."}, {"4307": "Writing the\u00a0Tests!"}, {"767e": "Let\u2019s go through our list of constraints and add a test for each. Every test will be written such that it can be inserted at the // All tests will go here comment in the boilerplate."}, {"e392": "All of the constraints thus far have been things that are always true, so their tests were relatively simple to write. However, the remaining constraints begin with words like \u201cIf\u201d and \u201cWhen\u201d. These are clues that they are conditionally true, and so we will pair describe with beforeEach to test them. This is where all that testing boilerplate we wrote earlier comes in handy."}, {"68ef": "When we need to describe behavior that only occurs within a certain condition, we can describe that condition, and then use beforeEach within that describe to set that condition up."}, {"2577": "That\u2019s all of our constraints! You can view the final test file here."}, {"c877": "\u201cNot My\u00a0Job\u201d"}, {"41d1": "When looking at the animated gif at the beginning of the article, you may have expected our test cases to end up as something like:"}, {"7ade": "This intuition is natural. From an application perspective, these are some of the most noticeable features."}, {"92db": "However, we didn\u2019t end up writing tests for any of that functionality. Why? They were not the concern of LockScreen."}, {"5305": "Because React components are reusable units, unit tests are a natural fit for them. And when unit testing, you should only test what your actual unit cares about. It is better to see the trees than the forest when writing React component tests."}, {"cab5": "Here is a handy cheat sheet that outlines the concerns of most React components:"}, {"4e0c": "The features described above are the concerns of SlideToUnlock and ClockDisplay, so tests around those features would go in the tests for those components, not here."}, {"22fc": "Summary"}, {"52b9": "I hope these methods will help you write your own React component tests. To summarize:"}, {"3305": "If you disagree or found this post helpful, I\u2019d love to hear from you on twitter. Let\u2019s all learn how to test React components together!"}, {"b609": "Stephen Scott is a developer at Nexia working on a unified Smart Home Automation System. Nexia is hiring! Ping Stephen on Twitter if you want to join our close-knit team of developers in-office in Broomfield, CO."}, {"0e3e": "Although this article is licensed all rights reserved, all code samples in this article are available under the MIT license, as found in their source repository on GitHub."}], "content": "The Right Way to Test React Components There\u2019s a lot of confusion right now about the \u201cright\u201d way to test your React components. Should you write all your tests by hand, or only use snapshots, or some of both? Should you test props? State? Styles/Layout? I don\u2019t think there\u2019s one \u201cright\u201d way, but I\u2019ve found a few patterns and tips that work really well for me that I\u2019d like to share. Background: The App We\u2019ll\u00a0Test Suppose you want to test a LockScreen component, which behaves like a phone\u2019s lock screen. It: It looks something like this: You can try it out here, and view the code on GitHub. Here\u2019s the code for the top-level App component: As you can see, LockScreen receives three props: wallpaperPath, userInfoMessage, and onUnlocked. Here\u2019s the code for LockScreen: LockScreen pulls in a few other components, but since we\u2019re only testing LockScreen, let\u2019s focus on it right now. Component Contracts In order to test LockScreen, you must first understand what its Contract is. Understanding a component\u2019s contract is the most important part of testing a React component. A contract defines the expected behavior of your component and what assumptions are reasonable to have about its usage. Without a clear contract, your component may be hard to understand. Writing tests is a great way to formally define your component\u2019s contract. Every React component has at least one thing that contributes to the definition of its contract: Additionally, most component contracts are affected by these things as well: Some less common things that affect component contracts are: To find your component\u2019s contract, ask yourself questions like: Finding LockScreen's Contract Let\u2019s go through LockScreen\u2019s render method and add comments at places where its behavior can differ. You\u2019ll look for ternaries, if statements, and switch statements as our clues. This will help us find variations in its contract. We\u2019ve learned three constraints that describe LockScreen's contract: You can also find some constraints of the contract that are always true: The component\u2019s propTypes are also a good place to look for clues about its contract. Here\u2019s some more constraints I notice: This is a good starting point for our component contract. There may be more constraints within this component\u2019s contract, and in production code you will want to find as many as you can, but for the purposes of this example, let\u2019s just work with these. You can always add tests later if you discover additional constraints. What\u2019s Worth\u00a0Testing? Let\u2019s look over the contract we found: Some of these constraints are worth testing, and others are not. Here are three rules of thumb I use to determine that something is not worth testing: These are only rules of thumb, so be careful not to use them to justify not testing something just because it\u2019s hard. Often, things that seem hard to test are the most important to test, because the code under test is making many assumptions about the rest of the application. Let\u2019s go through our constraints and use these rules of thumb to determine which need to be tested. Here\u2019s the first three: These constraints are a concern of React\u2019s PropTypes mechanism, and so writing tests around prop types fails rule #2 (already covered by library code). As such, I don\u2019t test prop types. Because tests often double as documentation, I might decide to test something that failed rule #2 if the application code didn\u2019t document the expected types very well, but propTypes are already nice and human-readable. Here\u2019s the next constraint: This can be broken down into three constraints: The first two constraints that we broke this down into do not fail any of our rules of thumb, so we will test them. However, let\u2019s look at the third one. Ignoring the background-image property that is covered by another constraint, the wrapping div has these styles: height: \"100%\",display: \"flex\",justifyContent: \"space-between\",flexDirection: \"column\",backgroundColor: \"black\",backgroundPosition: \"center\",backgroundSize: \"cover\", If we wrote a test that these styles were on the div, we would have to test the value of each style exactly in order to make useful assertions. So our assertions might be something like: Even if we used something like toMatchObject to keep this test succinct, this would duplicate the same styles in the application code, and be brittle. If we added another style, we would have to put the exact same code in our test. If we tweaked a style, we would have to tweak it in our test, even though the component\u2019s behavior may not have changed. Therefore, this constraint fails rule #1 (duplicates application code; brittle). For this reason, I don\u2019t test inline styles, unless they can change at runtime. Often, if you are writing a test that amounts to \u201cit does what it does\u201d, or \u201cit does exactly this, which happens to be duplicated in the application code\u201d, then the test is either unnecessary or too broad. Here\u2019s the next two constraints: These can be broken down into: These constraints fall into two categories: \u201cSome composite component is rendered\u201d, and \u201cthe rendered component receives these props\u201d. Both are very important to test, as they describe how your component interacts with other components. We will test all of these constraints. The next constraint is: You may think that, because this is an inline style, we do not need to test it. However, because the value of background-image can change based on the wallpaperPath prop, it needs to be tested. If we did not test it, then there would be no test around the effect of the wallpaperPath prop, which is part of the public interface of this component. You should always test your public interface. The final two constraints are: These can be broken down into: The first and fourth constraints (a TopOverlay should/should not be rendered) describe what we render, so we will test them. The second constraint verifies that the TopOverlay receives a particular prop based on the value of userInfoMessage. It is important to write tests around the props that rendered components receive, so we will test it. The third constraint verifies that TopOverlay receives a particular prop, so you might think that we should test it. However, this prop is just some inline styles. Asserting that props are passed is important, but making assertions about inline styles is brittle and duplicates application code (fails rule #1). Because it\u2019s important to test passed props, it\u2019s not clear whether this should be tested just by looking at rule #1 alone; luckily, that\u2019s why I have rule #3. As a reminder, it\u2019s: From an outsider\u2019s perspective, is this detail important, or is it only an internal concern? Can the effect of this internal detail be described using only the component\u2019s public API? When I write component tests, I only test the public API of the component (including side effects that API has on the application) where possible. The exact layout of this component is not impacted by this component\u2019s public API; it is a concern of the CSS engine. Because of this, this constraint fails rule #3. Because it fails rule #1 and rule #3, we will not test this constraint, even though it verifies that TopOverlay receives a prop, which is normally important. It was hard to determine whether that final constraint should be tested or not. Ultimately, it is up to you to decide which parts are important to test; these rules of thumb I use are only guidelines. Now we\u2019ve gone through all of our constraints, and know which ones we are going to write tests for. Here they are: By examining our constraints and putting them to scrutiny, we broke many of them down into multiple, smaller constraints. This is great! This will make it easier to write our test code. Setting Up Some Test Boilerplate Let\u2019s start scaffolding out a test for this component. I will be using Jest with enzyme in my tests. Jest works great with React and is also the test runner included in apps created with create-react-app, so you may already be set up to use it. Enzyme is a mature React testing library that works in both node and the browser. Even though I\u2019m using Jest and enzyme in my tests, you can apply the concepts here to almost any test configuration. This is a lot of boilerplate. Let me explain what I\u2019ve set up here: This boilerplate may seem like a lot just to test a component, but it lets us build up our props incrementally before we mount our component, which will help keep our tests dry. I use it for all of my component tests, and I hope you will find it useful; its utility will become more apparent as we write the test cases. Writing the\u00a0Tests! Let\u2019s go through our list of constraints and add a test for each. Every test will be written such that it can be inserted at the // All tests will go here comment in the boilerplate. All of the constraints thus far have been things that are always true, so their tests were relatively simple to write. However, the remaining constraints begin with words like \u201cIf\u201d and \u201cWhen\u201d. These are clues that they are conditionally true, and so we will pair describe with beforeEach to test them. This is where all that testing boilerplate we wrote earlier comes in handy. When we need to describe behavior that only occurs within a certain condition, we can describe that condition, and then use beforeEach within that describe to set that condition up. That\u2019s all of our constraints! You can view the final test file here. \u201cNot My\u00a0Job\u201d When looking at the animated gif at the beginning of the article, you may have expected our test cases to end up as something like: This intuition is natural. From an application perspective, these are some of the most noticeable features. However, we didn\u2019t end up writing tests for any of that functionality. Why? They were not the concern of LockScreen. Because React components are reusable units, unit tests are a natural fit for them. And when unit testing, you should only test what your actual unit cares about. It is better to see the trees than the forest when writing React component tests. Here is a handy cheat sheet that outlines the concerns of most React components: The features described above are the concerns of SlideToUnlock and ClockDisplay, so tests around those features would go in the tests for those components, not here. Summary I hope these methods will help you write your own React component tests. To summarize: If you disagree or found this post helpful, I\u2019d love to hear from you on twitter. Let\u2019s all learn how to test React components together! Stephen Scott is a developer at Nexia working on a unified Smart Home Automation System. Nexia is hiring! Ping Stephen on Twitter if you want to join our close-knit team of developers in-office in Broomfield, CO. Although this article is licensed all rights reserved, all code samples in this article are available under the MIT license, as found in their source repository on GitHub. ", "child": "966_1\t966_2\t966_3\t966_4\t966_5\t966_6\t966_7\t966_8\t966_9\t966_10\t966_11\t966_12\t966_13\t966_14\t966_15\t966_16\t966_17\t966_18\t966_19\t966_20966_1\t966_2\t966_3\t966_4\t966_5\t966_6\t966_7\t966_8\t966_9\t966_10\t966_11\t966_12\t966_13\t966_14\t966_15\t966_16\t966_17\t966_18\t966_19\t966_20966_1\t966_2\t966_3\t966_4\t966_5\t966_6\t966_7\t966_8\t966_9\t966_10\t966_11\t966_12\t966_13\t966_14\t966_15\t966_16\t966_17\t966_18\t966_19\t966_20"}