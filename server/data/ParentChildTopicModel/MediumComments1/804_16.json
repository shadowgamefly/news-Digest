{"content": "Courageous leap into a complex space, well done attempting it on your own. The same general tasks are covered in the upper division undergraduate / beginning grad student CS class on compilers. I took the prototype class back in the late 1970s, the first semester it was offered at my school and less than a year after it was first offered anywhere. Hard class. Good to know the tools have moved on from lex and yacc. One concern: the number of programming languages had already exploded by the time I started coding, to the point where there was a classic book with a drawing of the Tower of Babel on the front, each brick in the tower having the name of another programming language. Exploring new languages or language extensions is a fine research area, and a useful tool for learning as a student, but if you\u2019re writing code someone else will have to maintain, use a common language. Oh, and assembly language is not hard, it\u2019s very straightforward. I wrote thousands of lines of assembly language in high school and college days. The problem is that assembly language works best with entirely static and global allocation of variables, no stack or heap, an extraordinarily simple and unambiguous standard for which registers\u2019 values are preserved by calls and which are not, and a similarly simple memory map. It is inserting a little bit of assembly into (optimized) compiled code where none of these boundary conditions are clear or simple that\u2019s so hard. And free pointers, as anyone who\u2019s written in C has used. Oh, and that people are taught starting with languages which do all these things automatically for them these days, not starting with the simpleminded languages of my youth. ", "child": "", "name": "804_16", "parent": "804", "title": ""}