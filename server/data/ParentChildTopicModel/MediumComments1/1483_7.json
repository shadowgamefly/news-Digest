{"content": "I\u2019m easily\u00a0confused \u2026 in this case about the section \u201cLet\u2019s Test.\u201d GenericProtocol requires a static (type-level) func named introduce()->Void. (Let me call it sIntroduce(). I\u2019m easily confused.) Calling sIntroduce() on SomeStruct and SomeClass will compile because an extension on GenericProtocol gives them a default conforming implementation to fall back on. Additionally, if the associated type MyType is String (I need type names to be capitalized. I\u2019m easily confused, remember.), another extension provides a convenience instance func, iIntroduce()->Void. (Still easily confused, the prefix will help me keep it straight in my mind, and may help you explain where I\u2019m going wrong.) SomeStruct\u2019s MyType is String, so the convenience-defined func iIntroduce() exists, can be called, and would cause \u201cI\u2019m Bob the String-ish instance\u201d (\u201cthe String-ish instance\u201d added because I\u2019ve transcended easy confusion and arrived at prone-to-bafflement) to appear in the console. Also\u200a\u2014\u200abut it\u2019s not relevant here\u200a\u2014\u200aboth types (not instances, the types) would accept sIntroduce()->Void and print \u201cI\u2019m Bob the static\u201d (because I\u2019m not just easily-baffled but -confounded). First confusion SomeClass().iIntroduce() may be defined, but iIntroduce is defined as ()->Void. You shouldn\u2019t be able to initialize anything with the (lack of) result. Am I right? Second confusion The next line is \u201clet someStructInstance = SomeStruct()\u201d. How is this an error? Providing a convenience func for GenericProtocol where MyType is String doesn\u2019t add any uninitialized vars or lets to SomeStruct (if it did, the compiler would reject SomeStruct\u2019s definition as nonconforming). Shouldn\u2019t the instantiation should be correct, and valid to initialize a var? Did you mean SomeClass.sIntroduce() // compiles SomeClass().iIntroduce() // compiles SomeStruct.sIntroduce() // compiles SomeStruct().iIntroduce() // doesn\u2019t ? Also, is the constraint \u201cSelf == SomeClass\u201d just a simplified example, or is there a substantive difference from omitting that extension and simply defining sIntroduce() in SomeClass? If the latter, it\u2019d illuminate something I hadn\u2019t known. If the former, I might have said something like \u201c\u2026 and by now the extension is so narrow we might as well have extended SomeClass directly. We\u2019ve taken the technique so far it\u2019s come full circle.\u201d That would be an interesting perspective many readers would find helpful. The part about defaulting associated types is an eye-opener. Thanks! (Sorry for the code fragments in Roman type, I can\u2019t find that style in the iPad Medium app.) ", "child": "", "name": "1483_7", "parent": "1483", "title": ""}