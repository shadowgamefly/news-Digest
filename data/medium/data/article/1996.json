{"child": "1996_1\t1996_2\t1996_3\t1996_4\t1996_5\t1996_6\t1996_7\t1996_8\t1996_9\t1996_10\t1996_11\t1996_12\t1996_13\t1996_14\t1996_15\t1996_16\t1996_17\t1996_18\t1996_19\t1996_20\t1996_21\t1996_22\t1996_23\t1996_24\t1996_25", "title": "Presentational and Container Components", "content": "Presentational and Container Components Bismuth There\u2019s a simple pattern I find immensely useful when writing React applications. If you\u2019ve been doing React for a while, you have probably already discovered it. This article explains it well, but I want to add a few more points. You\u2019ll find your components much easier to reuse and reason about if you divide them into two categories. I call them Container and Presentational components* but I also heard Fat and Skinny, Smart and Dumb, Stateful and Pure, Screens and Components, etc. These all are not exactly the same, but the core idea is similar. My presentational components: My container components: I put them in different folders to make this distinction clear. Benefits of This\u00a0Approach Remember, components don\u2019t have to emit DOM. They only need to provide composition boundaries between UI concerns. Take advantage of that. When to Introduce Containers? I suggest you to start building your app with just presentational components first. Eventually you\u2019ll realize that you are passing too many props down the intermediate components. When you notice that some components don\u2019t use the props they receive but merely forward them down and you have to rewire all those intermediate components any time the children need more data, it\u2019s a good time to introduce some container components. This way you can get the data and the behavior props to the leaf components without burdening the unrelated components in the middle of the tree. This is an ongoing process of refactoring so don\u2019t try to get it right the first time. As you experiment with this pattern, you will develop an intuitive sense for when it\u2019s time to extract some containers, just like you know when it\u2019s time to extract a function. My free Redux Egghead series might help you with that too! Other Dichotomies It\u2019s important that you understand that the distinction between the presentational components and the containers is not a technical one. Rather, it is a distinction in their purpose. By contrast, here are a few related (but different!) technical distinctions: Both presentational components and containers can fall into either of those buckets. In my experience, presentational components tend to be stateless pure functions, and containers tend to be stateful pure classes. However this is not a rule but an observation, and I\u2019ve seen the exact opposite cases that made sense in specific circumstances. Don\u2019t take the presentational and container component separation as a dogma. Sometimes it doesn\u2019t matter or it\u2019s hard to draw the line. If you feel unsure about whether a specific component should be presentational or a container, it might be too early to decide. Don\u2019t sweat it! Example This gist by Michael Chan pretty much nails it. Further Reading Footnotes * In an earlier version of this article I called them \u201csmart\u201d and \u201cdumb\u201d components but this was overly harsh to the presentational components and, most importantly, didn\u2019t really explain the difference in their purpose. I enjoy the new terms much better, and I hope that you do too! ** In an earlier version of this article I claimed that presentational components should only contain other presentational components. I no longer think this is the case. Whether a component is a presentational component or a container is its implementation detail. You should be able to replace a presentational component with a container without modifying any of the call sites. Therefore, both presentational and container components can contain other presentational or container components just fine. ", "name": "1996", "parent": "", "sentences": [{"4683": "Presentational and Container Components"}, {"0151": "Bismuth"}, {"c0e4": "There\u2019s a simple pattern I find immensely useful when writing React applications. If you\u2019ve been doing React for a while, you have probably already discovered it. This article explains it well, but I want to add a few more points."}, {"7bdd": "You\u2019ll find your components much easier to reuse and reason about if you divide them into two categories. I call them Container and Presentational components* but I also heard Fat and Skinny, Smart and Dumb, Stateful and Pure, Screens and Components, etc. These all are not exactly the same, but the core idea is similar."}, {"8ce5": "My presentational components:"}, {"c27f": "My container components:"}, {"1f8c": "I put them in different folders to make this distinction clear."}, {"e027": "Benefits of This\u00a0Approach"}, {"5286": "Remember, components don\u2019t have to emit DOM. They only need to provide composition boundaries between UI concerns."}, {"4561": "Take advantage of that."}, {"7dc5": "When to Introduce Containers?"}, {"b804": "I suggest you to start building your app with just presentational components first. Eventually you\u2019ll realize that you are passing too many props down the intermediate components. When you notice that some components don\u2019t use the props they receive but merely forward them down and you have to rewire all those intermediate components any time the children need more data, it\u2019s a good time to introduce some container components. This way you can get the data and the behavior props to the leaf components without burdening the unrelated components in the middle of the tree."}, {"c74d": "This is an ongoing process of refactoring so don\u2019t try to get it right the first time. As you experiment with this pattern, you will develop an intuitive sense for when it\u2019s time to extract some containers, just like you know when it\u2019s time to extract a function. My free Redux Egghead series might help you with that too!"}, {"4c78": "Other Dichotomies"}, {"dc87": "It\u2019s important that you understand that the distinction between the presentational components and the containers is not a technical one. Rather, it is a distinction in their purpose."}, {"0145": "By contrast, here are a few related (but different!) technical distinctions:"}, {"c84e": "Both presentational components and containers can fall into either of those buckets. In my experience, presentational components tend to be stateless pure functions, and containers tend to be stateful pure classes. However this is not a rule but an observation, and I\u2019ve seen the exact opposite cases that made sense in specific circumstances."}, {"19ff": "Don\u2019t take the presentational and container component separation as a dogma. Sometimes it doesn\u2019t matter or it\u2019s hard to draw the line. If you feel unsure about whether a specific component should be presentational or a container, it might be too early to decide. Don\u2019t sweat it!"}, {"afa1": "Example"}, {"b342": "This gist by Michael Chan pretty much nails it."}, {"78e3": "Further Reading"}, {"1464": "Footnotes"}, {"c435": "* In an earlier version of this article I called them \u201csmart\u201d and \u201cdumb\u201d components but this was overly harsh to the presentational components and, most importantly, didn\u2019t really explain the difference in their purpose. I enjoy the new terms much better, and I hope that you do too!"}, {"e544": "** In an earlier version of this article I claimed that presentational components should only contain other presentational components. I no longer think this is the case. Whether a component is a presentational component or a container is its implementation detail. You should be able to replace a presentational component with a container without modifying any of the call sites. Therefore, both presentational and container components can contain other presentational or container components just fine."}]}