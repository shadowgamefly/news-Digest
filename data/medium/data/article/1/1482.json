{"parent": "", "timestamp": "Apr 2", "title": "Namespacing Swift code with nested\u00a0types", "sentences": [{"c565": "Namespacing Swift code with nested\u00a0types"}, {"3297": "While Swift does not yet feature a dedicated namespace keyword, it does support nesting types within others. Let\u2019s take a look at how using such nested types can help us improve the structure of our code."}, {"7aca": "Many Swift developers are used to do namespacing through including structural levels in the actual name of a type\u200a\u2014\u200ausing names like PostTextFormatterOption (an Option for a Text Formatter used to format Posts). This is probably because this was pretty much the only way to do sort of a \u201cpoor man\u2019s namespacing\u201d in Objective-C & C, and like many other conventions it has carried over to Swift."}, {"2d2f": "Let\u2019s use the type mentioned above as an example, and take a look at the implementations of Post, PostTextFormatter & PostTextFormatterOption:"}, {"bd4c": "Open as a\u00a0Gist"}, {"a5cd": "Now let\u2019s take a look at how the above types change if we instead structure them as nested types inside of Post:"}, {"689b": "Open as a\u00a0Gist"}, {"e917": "One big advantage of the nested types approach is that we can now clearly see the structure and relationship between our types just by taking a quick look at our code. We have also reduced the verbosity in our initializer, making it shorter and easier to read (the options argument is now simply of type Set<Option> instead of Set<PostTextFormatterOption>)."}, {"9d9e": "We now also get a clear sense of hierarchy at the call site\u200a\u2014\u200aeverything related to a Post is now neatly structured under the Post. namespace. Here\u2019s what formatting a post\u2019s text looks like:"}, {"8ae6": "Open as a\u00a0Gist"}, {"9271": "However, using nested types like above also has a pretty significant downside. The code is kind of \u201cbackwards\u201d vertically, where the actual content of the parent type gets pushed all the way down to the bottom. So let\u2019s try to fix that by flipping our structure\u200a\u2014\u200amoving our nested types down to the bottom, instead of having them at the top (we also throw in some MARKs, for good measure)."}, {"b07d": "Open as a\u00a0Gist"}, {"7857": "Whether you prefer the nested types to be on the top or bottom is definetly going to be a personal preference. I kind of like how it lets me keep the actual content of the parent type at the top\u200a\u2014\u200awhile still giving the code the hierarchical benefits of nested types."}, {"f9df": "However, like with many things in Swift, it turns out there\u2019s a couple of more ways to implement namespacing & nested types."}, {"d9ed": "Nested types in extensions"}, {"a34e": "One option is to use extensions to implement your nested types. This gives you a clearer separation between the types, while still retaining the hierarchy both in the implementation and at the call site."}, {"bee4": "Here\u2019s what that looks like for our types:"}, {"b955": "Open as a\u00a0Gist"}, {"846b": "Using typealiases"}, {"51f3": "You can also add typealiases to the original code (that didn\u2019t use nested types) to achieve a nested type-ish behavior. While this doesn\u2019t give you the same level of hierarchy in the implementation, it does help reduce the verbosity\u200a\u2014\u200aand it also provides the same benefits at the call site as when using nested types."}, {"fe18": "Here\u2019s what that option looks like:"}, {"d9c1": "Open as a\u00a0Gist"}, {"6f8b": "Conclusion"}, {"8670": "Using nested types can help you create a really nice structure & hierarchies in your code, to help make it clearer what the relationships are between your various types\u200a\u2014\u200aboth in the implementation and at the call site."}, {"8064": "However, depending on what technique you choose to implement them, you may face other challenges and side effects\u200a\u2014\u200aso I think picking the technique depending on the situation becomes really important, in order to end up with a net win."}, {"fcd8": "What do you think? Which one of the above techniques to you prefer for namespacing your code? Or have you found another one? Let me know, along with any questions or comments, on Twitter @johnsundell."}, {"306f": "(Oh, and by the way, as of Swift 3.1 nested types can also be used inside generics! \ud83c\udf89\u00a0\u2026but more on that in an upcoming post \ud83d\ude09)"}, {"36ca": "Thanks for reading! \ud83d\ude80"}, {"0154": "I write weekly blog post about Swift development here on Medium, and also work on several Swift open source projects on GitHub. You can also follow me on Twitter for updates on all my Swift adventures."}], "author": "John Sundell", "child": "1482_1\t1482_2\t1482_3\t1482_4", "name": "1482", "content": "Namespacing Swift code with nested\u00a0types While Swift does not yet feature a dedicated namespace keyword, it does support nesting types within others. Let\u2019s take a look at how using such nested types can help us improve the structure of our code. Many Swift developers are used to do namespacing through including structural levels in the actual name of a type\u200a\u2014\u200ausing names like PostTextFormatterOption (an Option for a Text Formatter used to format Posts). This is probably because this was pretty much the only way to do sort of a \u201cpoor man\u2019s namespacing\u201d in Objective-C & C, and like many other conventions it has carried over to Swift. Let\u2019s use the type mentioned above as an example, and take a look at the implementations of Post, PostTextFormatter & PostTextFormatterOption: Open as a\u00a0Gist Now let\u2019s take a look at how the above types change if we instead structure them as nested types inside of Post: Open as a\u00a0Gist One big advantage of the nested types approach is that we can now clearly see the structure and relationship between our types just by taking a quick look at our code. We have also reduced the verbosity in our initializer, making it shorter and easier to read (the options argument is now simply of type Set<Option> instead of Set<PostTextFormatterOption>). We now also get a clear sense of hierarchy at the call site\u200a\u2014\u200aeverything related to a Post is now neatly structured under the Post. namespace. Here\u2019s what formatting a post\u2019s text looks like: Open as a\u00a0Gist However, using nested types like above also has a pretty significant downside. The code is kind of \u201cbackwards\u201d vertically, where the actual content of the parent type gets pushed all the way down to the bottom. So let\u2019s try to fix that by flipping our structure\u200a\u2014\u200amoving our nested types down to the bottom, instead of having them at the top (we also throw in some MARKs, for good measure). Open as a\u00a0Gist Whether you prefer the nested types to be on the top or bottom is definetly going to be a personal preference. I kind of like how it lets me keep the actual content of the parent type at the top\u200a\u2014\u200awhile still giving the code the hierarchical benefits of nested types. However, like with many things in Swift, it turns out there\u2019s a couple of more ways to implement namespacing & nested types. Nested types in extensions One option is to use extensions to implement your nested types. This gives you a clearer separation between the types, while still retaining the hierarchy both in the implementation and at the call site. Here\u2019s what that looks like for our types: Open as a\u00a0Gist Using typealiases You can also add typealiases to the original code (that didn\u2019t use nested types) to achieve a nested type-ish behavior. While this doesn\u2019t give you the same level of hierarchy in the implementation, it does help reduce the verbosity\u200a\u2014\u200aand it also provides the same benefits at the call site as when using nested types. Here\u2019s what that option looks like: Open as a\u00a0Gist Conclusion Using nested types can help you create a really nice structure & hierarchies in your code, to help make it clearer what the relationships are between your various types\u200a\u2014\u200aboth in the implementation and at the call site. However, depending on what technique you choose to implement them, you may face other challenges and side effects\u200a\u2014\u200aso I think picking the technique depending on the situation becomes really important, in order to end up with a net win. What do you think? Which one of the above techniques to you prefer for namespacing your code? Or have you found another one? Let me know, along with any questions or comments, on Twitter @johnsundell. (Oh, and by the way, as of Swift 3.1 nested types can also be used inside generics! \ud83c\udf89\u00a0\u2026but more on that in an upcoming post \ud83d\ude09) Thanks for reading! \ud83d\ude80 I write weekly blog post about Swift development here on Medium, and also work on several Swift open source projects on GitHub. You can also follow me on Twitter for updates on all my Swift adventures. "}