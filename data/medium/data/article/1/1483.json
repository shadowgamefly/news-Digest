{"parent": "", "timestamp": "Apr 8", "title": "Generic Protocols with Associated Type", "sentences": [{"9edf": "Generic Protocols with Associated Type"}, {"e0c9": "Learn how to create generic protocol and override associated type"}, {"c472": "Introduction"}, {"f781": "You\u2019ve started learning Protocols and you\u2019ve got addicted to it. One day, you heard some words like associated type and type eraser. It seems rough and wild. I feel you. So, I wrote this tutorial for you. Let\u2019s get started."}, {"d3e2": "Goals"}, {"f96a": "There are two objectives. First, learn how to create a generic protocol with associatedtype. Second, use where clauses for type constraints similar to that of generics."}, {"a355": "Prerequisites"}, {"aa83": "I consider this tutorial as somewhat intermediate-advanced. So, I expect you to be familiar with the topics below."}, {"e944": "Intro to Generics (Blog)"}, {"bc9b": "Intro to Protocol Oriented Programming (Blog)"}, {"f5bf": "Closure (Blog)"}, {"b016": "Typealias (Google)"}, {"bb95": "Besides that you may visit here for every resource I\u2019ve made for you guys for free or join my mailing list to get more value from me. I\u2019m going to be around a while. I plan to cover server-side Swift, RxSwift, Test driven, and all the good stuff. \ud83d\ude03"}, {"149d": "The Number One\u00a0Rules"}, {"bfdf": "The Swift Programming Language is considered as type-safe. It means, the type must be defined before compiled."}, {"1f7e": "Review"}, {"bd57": "Before we dive into generic protocols, you should be familiar with the following code below."}, {"406b": "struct GenericStruct<T> { var property: T?}"}, {"8250": "I could either explicitly state the type of T or let Swift infer based on the value."}, {"d34b": "let explictStruct = GenericStruct<Bool>() // T is Bool "}, {"c1e9": "let implicitStruct = GenericStruct(property: \"Bob\")// T is String"}, {"84cc": "Keep in mind of the principle that every type must be\u00a0defined."}, {"fa9e": "Normal Protocol"}, {"16e4": "First, to appreciate generic protocols, let\u2019s look into your/my past. Let\u2019s create a protocol that requires you to add property whose type is String."}, {"ba1d": "Design Protocol"}, {"d9e2": "protocol NormalProtocol { var property: String { get set }}"}, {"d44c": "Design Class and\u00a0Conform"}, {"3b53": "class NormalClass: NormalProtocol { var property: String = \"Bob\"}"}, {"6795": "Sounds good. However, NormalProtocol forces NormalClass to work with String. But, what if you want property to be Int or Bool?"}, {"761b": "It\u2019s time to introduce Protocol Associated Types. \ud83d\ude0e (I should have a thug-life meme)"}, {"6686": "Introducing Protocol Associated Types"}, {"50e4": "In generic protocols, to create something like <T> in generics, you need to add associatedtype."}, {"dd37": "protocol GenericProtocol { associatedtype myType var anyProperty: myType { get set }}"}, {"b583": "Associated type = type alias +\u00a0generics"}, {"adc8": "Now, anything that conforms to GenericProtocol must implement anyProperty. However, the type is not defined. Therefore, the class or struct that conforms to the protocol must define it either implicitly or explicitly."}, {"67aa": "First, let\u2019s create a class SomeClass that conforms to GenericProtocol. We must define myType. Well, there are two ways to define as stated above."}, {"74f4": "Define Associated Type Implicitly"}, {"0a09": "You may define myType based on the value associated with anyProperty."}, {"e84b": "class SomeClass: GenericProtocol { var anyProperty: myType = \"Bob\"}"}, {"7623": "Now, myType has been defined as String based on \u201cBob\u201d. However, you can let Swift do more guessing as shown below."}, {"6c29": "class SomeClass: GenericProtocol { var anyProperty = \"Bob\" // myType is \"String\"}"}, {"d4c9": "Is everything okay with you? If so far so good, you can show me some love through \u2764\ufe0f."}, {"4985": "Define Associated Type Explicitly"}, {"9505": "Well, you may also define the associated type, myType by calling typealias. What? Let\u2019s take a look."}, {"7b2e": "class SomeClass: GenericProtocol { typealias myType = String var anyProperty: myType = \"Bob\"}"}, {"dd86": "If you want to define the associatedtype a.k.a myType, you may use typealias. Of course, it is not necessary since you may define myType implicitly as we\u2019ve seen."}, {"e4bf": "So far, you\u2019ve defined myType as String. Let\u2019s create a struct that conforms to GenericProtocol but myType is Int instead."}, {"f0f3": "struct SomeStruct: GenericProtocol { var anyProperty = 1996}"}, {"7505": "You\u2019ve implicitly stated that myType is Int based on the value of 1996."}, {"d333": "If you hear Protocol Associated Types (PATs), it just means generic protocols."}, {"ac38": "Protocol Extension and Type Constraints"}, {"8704": "As you already know, Protocol extension is amazing because it provides default implementations without having to define required methods and properties. Let\u2019s review."}, {"7036": "Design Extension"}, {"0f19": "extension GenericProtocol { static func introduce() {  print(\"I'm Bob\") }}"}, {"1a11": "Anything that adopts GenericProtocol now contains this magic."}, {"486e": "SomeClass.introduce() // I'm BobSomeStruct.introduce() // I'm Bob "}, {"cf7f": "But all of a sudden, you only want myType as String to have the introduce() method. How do you go about?"}, {"d932": "Introducing Where\u00a0Clause"}, {"85cb": "Don\u2019t worry if you have never used where. It\u2019s just a shorter way to write an else-if statement."}, {"a573": "Let\u2019s s add introduce() for those who not only conform to GenericProtocol but also has the associatedtype\u00a0,a.k.a myType as String."}, {"a58c": "extension GenericProtocol where myType == String { func introduce(){  print(\"I'm Bob\") }}"}, {"c370": "The where clause above state, if myType is String, proceed, if not ignore the entire extension block."}, {"0f62": "Let\u2019s Test"}, {"29ff": "If you remember, SomeClass has String and SomeStruct has Int."}, {"21bd": "let someClassInstance = SomeClass().introduce() // \"I'm Bob\""}, {"57ef": "Let\u2019s attempt for SomeStruct."}, {"caf4": "let someStructInstance = SomeStruct() // Error "}, {"7513": "Multiple Where Conditions with\u00a0Self"}, {"40ed": "You may add multiple where clauses to make the extension more specific. All you have to do is just add\u00a0, and more conditions after."}, {"9127": "This time, we will add one more constraint that onlySomeClass may have the introduce() method."}, {"aeac": "extension GenericProtocol where type == String, Self == SomeClass { func introduce(){  print(\"I'm Bob\")  }}"}, {"14fc": "The Self refers to the struct/class/enum that conforms GenericProtocol. As a result, only SomeClass will have the introduce() method."}, {"dd9a": "So far so good?"}, {"768a": "Override Associated Type"}, {"8232": "So far, in GenericProtocol, we have not defined associatedtype within the protocol itself."}, {"dc58": "protocol GenericProtocol { associatedtype myType var anyProperty: myType { get set }}"}, {"6951": "The type of myType has been defined by those who conform to the protocol. However, you may also pre-defined associatedtype within a protocol as well."}, {"e8e0": "Associated Type Pre-Defined Protocol"}, {"f59a": "Let\u2019s create a protocol called, Familiable. It contains an associatedtype called FamilyType. But, you\u2019ve pre-defined its type as Int."}, {"5af8": "protocol Familiable { associatedtype FamilyType = Int func getName() -> [FamilyType]}"}, {"c07f": "It somewhat looks like a typealias."}, {"53ef": "Adopt Type Pre-defined Protocol"}, {"ce43": "class NumberFamily: Familiable { func getName() -> [FamilyType] {  return [1, 2, 3] }}"}, {"3514": "or"}, {"d325": "class NumberFamily: Familiable { func getName() -> [Int] {  return [1, 2, 3] }}"}, {"f53c": "Now, if you create an instance,"}, {"c4ee": "let numberFam = NumberFamily() // NumberFamily<Int>"}, {"1ca7": "However, it is possible to override/change the pre-defined type of a protocol."}, {"0e9c": "Override Associated Type"}, {"8164": "First, we will create a generic struct called, NormalFamily. It conforms to Familiable. That means Familiable will force the struct to work with Int. However, you refuse."}, {"d031": "You want your struct to work with String since a normal family should have names like \u201cBob\u201d or \u201cBobby\u201d instead of 1, 2, 3."}, {"4783": "struct NormalFamily<T: ExpressibleByStringLiteral>: Familiable  { func getName() -> [T] {  return [\"Bob\", \"Bobby\", \"Lee\"] }}"}, {"2560": "Now, if you create an instance,"}, {"e482": "let normalFam = NormalFamily() // NormalFamily<String>"}, {"3fc5": "How is this possible? Well, if you option-click on String in Swift, you will discover, String conforms to ExpressibleByStringLiteral."}, {"e385": "// Swift Library extension String : ExpressibleByStringLiteral {} "}, {"f9a9": "That\u2019s it."}, {"2e76": "Last Remarks"}, {"aec1": "In this tutorial, you\u2019ve learned how to override associatedtype and even combine protocols with generics. How was your learning going? If you learned something new, I\u2019d appreciate your fat \u2764\ufe0f. We\u2019ve talked about a lot of theories in this article. Of course, if you want to learn practical Protocol Oriented Programming, RxSwift, MVVM, I highly recommend you to join my mailing list. Again, I\u2019m going to be around for you guys and you don\u2019t miss a single thing from me. \ud83d\udcaa"}, {"2c25": "lSource Code"}, {"7198": "The Resource\u00a0Page"}, {"9276": "Next Article"}, {"5dd2": "You\u2019ve come a long way. I\u2019m very happy for you. However, you are missing just one thing: Type Eraser. I will write one next week. You can either follow this blog or Facebook Page"}, {"198f": "Bob the Developer"}, {"ea5f": "I\u2019m an iOS instructor from Seoul, \ud83c\uddf0\ud83c\uddf7. Feel free to get to know me on Instagram. I post regular updates on Facebook Page and \ud83d\udda8 on Sat 8pm EST."}], "author": "Bob Lee", "child": "1483_1\t1483_2\t1483_3\t1483_4\t1483_5\t1483_6\t1483_7\t1483_8\t1483_9\t1483_10\t1483_11\t1483_12\t1483_131483_1\t1483_2\t1483_3\t1483_4\t1483_5\t1483_6\t1483_7\t1483_8\t1483_9\t1483_10\t1483_11\t1483_12\t1483_13", "name": "1483", "content": "Generic Protocols with Associated Type Learn how to create generic protocol and override associated type Introduction You\u2019ve started learning Protocols and you\u2019ve got addicted to it. One day, you heard some words like associated type and type eraser. It seems rough and wild. I feel you. So, I wrote this tutorial for you. Let\u2019s get started. Goals There are two objectives. First, learn how to create a generic protocol with associatedtype. Second, use where clauses for type constraints similar to that of generics. Prerequisites I consider this tutorial as somewhat intermediate-advanced. So, I expect you to be familiar with the topics below. Intro to Generics (Blog) Intro to Protocol Oriented Programming (Blog) Closure (Blog) Typealias (Google) Besides that you may visit here for every resource I\u2019ve made for you guys for free or join my mailing list to get more value from me. I\u2019m going to be around a while. I plan to cover server-side Swift, RxSwift, Test driven, and all the good stuff. \ud83d\ude03 The Number One\u00a0Rules The Swift Programming Language is considered as type-safe. It means, the type must be defined before compiled. Review Before we dive into generic protocols, you should be familiar with the following code below. struct GenericStruct<T> { var property: T?} I could either explicitly state the type of T or let Swift infer based on the value. let explictStruct = GenericStruct<Bool>() // T is Bool  let implicitStruct = GenericStruct(property: \"Bob\")// T is String Keep in mind of the principle that every type must be\u00a0defined. Normal Protocol First, to appreciate generic protocols, let\u2019s look into your/my past. Let\u2019s create a protocol that requires you to add property whose type is String. Design Protocol protocol NormalProtocol { var property: String { get set }} Design Class and\u00a0Conform class NormalClass: NormalProtocol { var property: String = \"Bob\"} Sounds good. However, NormalProtocol forces NormalClass to work with String. But, what if you want property to be Int or Bool? It\u2019s time to introduce Protocol Associated Types. \ud83d\ude0e (I should have a thug-life meme) Introducing Protocol Associated Types In generic protocols, to create something like <T> in generics, you need to add associatedtype. protocol GenericProtocol { associatedtype myType var anyProperty: myType { get set }} Associated type = type alias +\u00a0generics Now, anything that conforms to GenericProtocol must implement anyProperty. However, the type is not defined. Therefore, the class or struct that conforms to the protocol must define it either implicitly or explicitly. First, let\u2019s create a class SomeClass that conforms to GenericProtocol. We must define myType. Well, there are two ways to define as stated above. Define Associated Type Implicitly You may define myType based on the value associated with anyProperty. class SomeClass: GenericProtocol { var anyProperty: myType = \"Bob\"} Now, myType has been defined as String based on \u201cBob\u201d. However, you can let Swift do more guessing as shown below. class SomeClass: GenericProtocol { var anyProperty = \"Bob\" // myType is \"String\"} Is everything okay with you? If so far so good, you can show me some love through \u2764\ufe0f. Define Associated Type Explicitly Well, you may also define the associated type, myType by calling typealias. What? Let\u2019s take a look. class SomeClass: GenericProtocol { typealias myType = String var anyProperty: myType = \"Bob\"} If you want to define the associatedtype a.k.a myType, you may use typealias. Of course, it is not necessary since you may define myType implicitly as we\u2019ve seen. So far, you\u2019ve defined myType as String. Let\u2019s create a struct that conforms to GenericProtocol but myType is Int instead. struct SomeStruct: GenericProtocol { var anyProperty = 1996} You\u2019ve implicitly stated that myType is Int based on the value of 1996. If you hear Protocol Associated Types (PATs), it just means generic protocols. Protocol Extension and Type Constraints As you already know, Protocol extension is amazing because it provides default implementations without having to define required methods and properties. Let\u2019s review. Design Extension extension GenericProtocol { static func introduce() {  print(\"I'm Bob\") }} Anything that adopts GenericProtocol now contains this magic. SomeClass.introduce() // I'm BobSomeStruct.introduce() // I'm Bob  But all of a sudden, you only want myType as String to have the introduce() method. How do you go about? Introducing Where\u00a0Clause Don\u2019t worry if you have never used where. It\u2019s just a shorter way to write an else-if statement. Let\u2019s s add introduce() for those who not only conform to GenericProtocol but also has the associatedtype\u00a0,a.k.a myType as String. extension GenericProtocol where myType == String { func introduce(){  print(\"I'm Bob\") }} The where clause above state, if myType is String, proceed, if not ignore the entire extension block. Let\u2019s Test If you remember, SomeClass has String and SomeStruct has Int. let someClassInstance = SomeClass().introduce() // \"I'm Bob\" Let\u2019s attempt for SomeStruct. let someStructInstance = SomeStruct() // Error  Multiple Where Conditions with\u00a0Self You may add multiple where clauses to make the extension more specific. All you have to do is just add\u00a0, and more conditions after. This time, we will add one more constraint that onlySomeClass may have the introduce() method. extension GenericProtocol where type == String, Self == SomeClass { func introduce(){  print(\"I'm Bob\")  }} The Self refers to the struct/class/enum that conforms GenericProtocol. As a result, only SomeClass will have the introduce() method. So far so good? Override Associated Type So far, in GenericProtocol, we have not defined associatedtype within the protocol itself. protocol GenericProtocol { associatedtype myType var anyProperty: myType { get set }} The type of myType has been defined by those who conform to the protocol. However, you may also pre-defined associatedtype within a protocol as well. Associated Type Pre-Defined Protocol Let\u2019s create a protocol called, Familiable. It contains an associatedtype called FamilyType. But, you\u2019ve pre-defined its type as Int. protocol Familiable { associatedtype FamilyType = Int func getName() -> [FamilyType]} It somewhat looks like a typealias. Adopt Type Pre-defined Protocol class NumberFamily: Familiable { func getName() -> [FamilyType] {  return [1, 2, 3] }} or class NumberFamily: Familiable { func getName() -> [Int] {  return [1, 2, 3] }} Now, if you create an instance, let numberFam = NumberFamily() // NumberFamily<Int> However, it is possible to override/change the pre-defined type of a protocol. Override Associated Type First, we will create a generic struct called, NormalFamily. It conforms to Familiable. That means Familiable will force the struct to work with Int. However, you refuse. You want your struct to work with String since a normal family should have names like \u201cBob\u201d or \u201cBobby\u201d instead of 1, 2, 3. struct NormalFamily<T: ExpressibleByStringLiteral>: Familiable  { func getName() -> [T] {  return [\"Bob\", \"Bobby\", \"Lee\"] }} Now, if you create an instance, let normalFam = NormalFamily() // NormalFamily<String> How is this possible? Well, if you option-click on String in Swift, you will discover, String conforms to ExpressibleByStringLiteral. // Swift Library extension String : ExpressibleByStringLiteral {}  That\u2019s it. Last Remarks In this tutorial, you\u2019ve learned how to override associatedtype and even combine protocols with generics. How was your learning going? If you learned something new, I\u2019d appreciate your fat \u2764\ufe0f. We\u2019ve talked about a lot of theories in this article. Of course, if you want to learn practical Protocol Oriented Programming, RxSwift, MVVM, I highly recommend you to join my mailing list. Again, I\u2019m going to be around for you guys and you don\u2019t miss a single thing from me. \ud83d\udcaa lSource Code The Resource\u00a0Page Next Article You\u2019ve come a long way. I\u2019m very happy for you. However, you are missing just one thing: Type Eraser. I will write one next week. You can either follow this blog or Facebook Page Bob the Developer I\u2019m an iOS instructor from Seoul, \ud83c\uddf0\ud83c\uddf7. Feel free to get to know me on Instagram. I post regular updates on Facebook Page and \ud83d\udda8 on Sat 8pm EST. "}