{"name": "459", "parent": "", "content": "GraphQL today using Apollo for client apps that still depend on REST\u00a0APIs Even though people using GraphQL are often extremely excited about the technology, it\u2019s popularity is still growing slowly. Developers working on client-side applications are the ones to benefit the most from GraphQL, but migrating a backend from a working REST API might not be economically justifiable for most teams. What most don\u2019t realize, though, is that it is not completely necessary to make the switch on both sides before adopting the technology. The main JavaScript implementation of a GraphQL server runs just fine on the browser, and Apollo makes it easy as cake to start using it today. If you plan to use Relay to achieve the same goal, you should definitely check this post on the official GraphQL blog. Who/what is\u00a0Apollo? GraphQL is ultimately only a protocol, meaning there are dozens of projects for both client and server side implementations of it. Apollo, in the other hand, is a suite of open-source tools & products built by (very nice folks at) the Meteor Development Group. Among these projects, there is graphql-tools, which facilitates the creation of a executable schema, and apollo-client, which presents itself as \u201cThe fully-featured, production ready caching GraphQL client for every server or UI framework\u201d. Quite bold, huh? Resolving GraphQL in the\u00a0browser The first problem to be solved here is how to run a GraphQL server/resolver in the client-side. To be honest, it is not much of a problem really. As I said before, the main JavaScript implementation of GraphQL works in the browser, and all we have to do is use it as we would in a Node server. So let\u2019s go on with it. Installation We are going to need two schema building tools: Missing NPM in the command? You should definitely give Yarn a try\u00a0;) Building the GraphQL\u00a0Schema First things first. Building a schema is rather easy with graphql-tools. You start by defining a schema using the GraphQL schema language as follows: What we are saying here is that our schema has a single type called Query and that this is the root query type, meaning it\u2019s fields are queryable at the top level of the schema\u200a\u2014\u200ain this case, the helloWorld field, which resolves to a string. Then you define resolvers as a nested object that maps type and field names to resolver functions: More info on graphql-tools resolver maps can be found on this guide. Finally, you combine the type definitions and the resolvers into an executable schema using makeExecutableSchema helper: Apollo has a documentation section on modularizing the schema, and I\u2019ve also worked on the subject and created a project which might be useful, though it is in early stages: graphql-modules. During this tutorial, though, we\u2019ll have only one file to keep things simple. Executing queries After we\u2019ve managed to create an executable schema, we can resolve queries against it using the official graphql-js project as follows: Done! We can resolve GraphQL. The code so far can be bundled using webpack or whatever tool you use to build your code to be executed in the browser, and it will work just fine. I\u2019ve created a repository to serve as code reference for this post. It\u2019s available on GitHub, it has a ready to use building system and node server for you to try the code presented here. Checkout the tag 1-hello-world to see this check\u00a0point. Resolving using REST API\u00a0calls Now that you have a way to resolve GraphQL queries in the browser, we can move forward and add a more advanced schema, with resolvers that map to REST requests. To keep up with simplicity, I\u2019ll use an online fake REST API called JSONPlaceholder. It has a rough blog schema, with posts, users, comments, etc, which is just perfect for our use case. First of all, let\u2019s update our schema to define these new types: Now, we\u2019ll update the resolver map as follows: Note that to fetch REST endpoints we are using Fetch API. You can polyfill it if you need with whatwg-fetch, but it is already available on all major browsers. No we can query posts: Checkpoint: checkout to tag 2-rest-resolvers on the code reference repo to try this out on your\u00a0browser. Ok, that\u2019s pretty cool. What if we wanted to get a single post from the API, though? Well, easy enough. Here is how we could make a query for the post with id 1: Now, having a look at our mocked API for posts, we can see that it returns yet a fourth property on each post object: the userId. That's a good time for... Resolving relations Relations in GraphQL are simply more resolvers, as I expect you already know. Follow up as we add the Post\u2019s author field to the schema, as well as the User\u2019s posts field, together with their resolvers: To remember what function parameters we are using this relation resolvers, have a look at the resolver function signature. Ok, things are becoming really interesting. Now we can make GraphQL work it\u2019s magic, doing crazy stuff such as \u201cgrabbing the posts with the same author as post 1\u201d: Oooh, that\u2019s truly amazing! I\u2019ll just take break for a coffee and contemplate such good work we\u2019ve accomplished so far\u2026 Meanwhile, another checkpoint for you to run: 3-relationship-resolvers. Now, mutations! Mutations in GraphQL are just more field resolvers, only with some additional behavior. Having that said, to create addPost mutation we will basically create a resolver that fetches using the HTTP method POST as follows: Side note about the code above: our mocked API accepts POST requests, but returns only the supposedly generated id in the response, nothing more. Our mutation queries then have to be identified as such: Two more checkpoints and we\u2019re done: 4-mutation-resolvers. Apollo Client Ok, I know that running a static query stored in a variable in the index.js of our application isn\u2019t going to be enough for long. The next step is integrating what we already have with Apollo Client (\u201cThe fully-featured, production ready caching GraphQL client for every server or UI framework\u201d. Again: long description, not modest, but quite accurate). Installation Creating the\u00a0client To create an Apollo Client instance you must instantiate the ApolloClient class with a configuration object containing, at least, the network interface which the client will use to make GraphQL requests. Usually, in a front-end/back-end application this means using the included helper createNetworkInterface, which would basically send POST requests to a backend on the same domain of the running application. It looks pretty much like this: If you are interested, you can find out more on the Network layer of the Apollo Client. And, to perform a query, something like this: The code above would be just fine if we had a backend serving GraphQL\u200a\u2014\u200awhich we don\u2019t. Good enough we\u2019ve being building our own wrap around the REST API just earlier in this post. Connecting the\u00a0dots What we now have to do is make ApolloClient use the GraphQL schema and resolver we built as were we doing before: If you are interested, you can find out more on the Network layer of the Apollo Client. Ok, what the heck is going on here? First, we are instantiating ApolloClient with a completely custom networkInterface. It consists of an object with the single required method query, which will be called by the client to resolve queries. This method will receive a single argument; an ApolloClient Request Interface. Second, we use an available helper, printAST, to process this request object back into a valid GraphQL query string (much similar to the ones we were statically using before). Third, we extract other import things from this request object, such as an operationName and possible variables to provide the resolver with. Last but not least, we run the query against the schema as have we done before, providing it with the schema, the query, the initial root, a context (null here, for we don\u2019t need it yet), the variables, and the operation name, in that exact arguments order. Most of the arguments are not mandatory, as we\u2019ve seen this same function be executed with only the first two just a few words back in this post. Trump is really\u00a0amazed If you have any question about the query execution part, please have a look at GraphQL\u2019s official documentation on query execution. We can now use the client as we normally would: Time for one final checkpoint: 5-apollo-client. Conclusion This is pretty much it. I hope you all found your way in this wandering of GraphQL learning, and above all, I hope you are now able to start using GraphQL today, no more excuses allowed. Post credit\u00a0scene Ok, if you are really just starting with GraphQL you might not even know what to do with this ApolloClient we\u2019ve ended up with. Our index.js is still just resolving a single query. My bad. I understand that if you are here you probably already use some framework such as React, Meteor, Angular, or even Vue (but only if you are a true hipster). If that\u2019s the case, here are the libraries you are looking for: See ya! Originally published at taller.net.br. ", "title": "GraphQL today using Apollo for client apps that still depend on REST\u00a0APIs", "sentences": [{"2d6e": "GraphQL today using Apollo for client apps that still depend on REST\u00a0APIs"}, {"4298": "Even though people using GraphQL are often extremely excited about the technology, it\u2019s popularity is still growing slowly. Developers working on client-side applications are the ones to benefit the most from GraphQL, but migrating a backend from a working REST API might not be economically justifiable for most teams. What most don\u2019t realize, though, is that it is not completely necessary to make the switch on both sides before adopting the technology. The main JavaScript implementation of a GraphQL server runs just fine on the browser, and Apollo makes it easy as cake to start using it today."}, {"7d6d": "If you plan to use Relay to achieve the same goal, you should definitely check this post on the official GraphQL blog."}, {"b01b": "Who/what is\u00a0Apollo?"}, {"ad6e": "GraphQL is ultimately only a protocol, meaning there are dozens of projects for both client and server side implementations of it. Apollo, in the other hand, is a suite of open-source tools & products built by (very nice folks at) the Meteor Development Group."}, {"b384": "Among these projects, there is graphql-tools, which facilitates the creation of a executable schema, and apollo-client, which presents itself as \u201cThe fully-featured, production ready caching GraphQL client for every server or UI framework\u201d. Quite bold, huh?"}, {"73f8": "Resolving GraphQL in the\u00a0browser"}, {"9bb9": "The first problem to be solved here is how to run a GraphQL server/resolver in the client-side. To be honest, it is not much of a problem really. As I said before, the main JavaScript implementation of GraphQL works in the browser, and all we have to do is use it as we would in a Node server. So let\u2019s go on with it."}, {"8966": "Installation"}, {"837b": "We are going to need two schema building tools:"}, {"c847": "Missing NPM in the command? You should definitely give Yarn a try\u00a0;)"}, {"ebc1": "Building the GraphQL\u00a0Schema"}, {"8a44": "First things first. Building a schema is rather easy with graphql-tools. You start by defining a schema using the GraphQL schema language as follows:"}, {"5776": "What we are saying here is that our schema has a single type called Query and that this is the root query type, meaning it\u2019s fields are queryable at the top level of the schema\u200a\u2014\u200ain this case, the helloWorld field, which resolves to a string."}, {"4700": "Then you define resolvers as a nested object that maps type and field names to resolver functions:"}, {"6cbd": "More info on graphql-tools resolver maps can be found on this guide."}, {"eb29": "Finally, you combine the type definitions and the resolvers into an executable schema using makeExecutableSchema helper:"}, {"316d": "Apollo has a documentation section on modularizing the schema, and I\u2019ve also worked on the subject and created a project which might be useful, though it is in early stages: graphql-modules. During this tutorial, though, we\u2019ll have only one file to keep things simple."}, {"8a9f": "Executing queries"}, {"0789": "After we\u2019ve managed to create an executable schema, we can resolve queries against it using the official graphql-js project as follows:"}, {"7324": "Done! We can resolve GraphQL. The code so far can be bundled using webpack or whatever tool you use to build your code to be executed in the browser, and it will work just fine."}, {"ef48": "I\u2019ve created a repository to serve as code reference for this post. It\u2019s available on GitHub, it has a ready to use building system and node server for you to try the code presented here. Checkout the tag 1-hello-world to see this check\u00a0point."}, {"da72": "Resolving using REST API\u00a0calls"}, {"52ef": "Now that you have a way to resolve GraphQL queries in the browser, we can move forward and add a more advanced schema, with resolvers that map to REST requests."}, {"2f44": "To keep up with simplicity, I\u2019ll use an online fake REST API called JSONPlaceholder. It has a rough blog schema, with posts, users, comments, etc, which is just perfect for our use case."}, {"e701": "First of all, let\u2019s update our schema to define these new types:"}, {"f7e9": "Now, we\u2019ll update the resolver map as follows:"}, {"fd96": "Note that to fetch REST endpoints we are using Fetch API. You can polyfill it if you need with whatwg-fetch, but it is already available on all major browsers."}, {"6bcc": "No we can query posts:"}, {"efb0": "Checkpoint: checkout to tag 2-rest-resolvers on the code reference repo to try this out on your\u00a0browser."}, {"e462": "Ok, that\u2019s pretty cool. What if we wanted to get a single post from the API, though? Well, easy enough. Here is how we could make a query for the post with id 1:"}, {"0cfc": "Now, having a look at our mocked API for posts, we can see that it returns yet a fourth property on each post object: the userId. That's a good time for..."}, {"d409": "Resolving relations"}, {"56d0": "Relations in GraphQL are simply more resolvers, as I expect you already know. Follow up as we add the Post\u2019s author field to the schema, as well as the User\u2019s posts field, together with their resolvers:"}, {"b65b": "To remember what function parameters we are using this relation resolvers, have a look at the resolver function signature."}, {"e749": "Ok, things are becoming really interesting. Now we can make GraphQL work it\u2019s magic, doing crazy stuff such as \u201cgrabbing the posts with the same author as post 1\u201d:"}, {"bf07": "Oooh, that\u2019s truly amazing! I\u2019ll just take break for a coffee and contemplate such good work we\u2019ve accomplished so far\u2026"}, {"e552": "Meanwhile, another checkpoint for you to run: 3-relationship-resolvers."}, {"92a3": "Now, mutations!"}, {"4de7": "Mutations in GraphQL are just more field resolvers, only with some additional behavior. Having that said, to create addPost mutation we will basically create a resolver that fetches using the HTTP method POST as follows:"}, {"119b": "Side note about the code above: our mocked API accepts POST requests, but returns only the supposedly generated id in the response, nothing more."}, {"779d": "Our mutation queries then have to be identified as such:"}, {"9fa9": "Two more checkpoints and we\u2019re done: 4-mutation-resolvers."}, {"fa61": "Apollo Client"}, {"0e74": "Ok, I know that running a static query stored in a variable in the index.js of our application isn\u2019t going to be enough for long. The next step is integrating what we already have with Apollo Client (\u201cThe fully-featured, production ready caching GraphQL client for every server or UI framework\u201d. Again: long description, not modest, but quite accurate)."}, {"47aa": "Installation"}, {"118f": "Creating the\u00a0client"}, {"8a12": "To create an Apollo Client instance you must instantiate the ApolloClient class with a configuration object containing, at least, the network interface which the client will use to make GraphQL requests. Usually, in a front-end/back-end application this means using the included helper createNetworkInterface, which would basically send POST requests to a backend on the same domain of the running application. It looks pretty much like this:"}, {"b61e": "If you are interested, you can find out more on the Network layer of the Apollo Client."}, {"0477": "And, to perform a query, something like this:"}, {"5ed9": "The code above would be just fine if we had a backend serving GraphQL\u200a\u2014\u200awhich we don\u2019t. Good enough we\u2019ve being building our own wrap around the REST API just earlier in this post."}, {"3cfa": "Connecting the\u00a0dots"}, {"af79": "What we now have to do is make ApolloClient use the GraphQL schema and resolver we built as were we doing before:"}, {"bf50": "If you are interested, you can find out more on the Network layer of the Apollo Client."}, {"3a6d": "Ok, what the heck is going on here?"}, {"177d": "First, we are instantiating ApolloClient with a completely custom networkInterface. It consists of an object with the single required method query, which will be called by the client to resolve queries. This method will receive a single argument; an ApolloClient Request Interface."}, {"a120": "Second, we use an available helper, printAST, to process this request object back into a valid GraphQL query string (much similar to the ones we were statically using before)."}, {"f502": "Third, we extract other import things from this request object, such as an operationName and possible variables to provide the resolver with."}, {"86ba": "Last but not least, we run the query against the schema as have we done before, providing it with the schema, the query, the initial root, a context (null here, for we don\u2019t need it yet), the variables, and the operation name, in that exact arguments order. Most of the arguments are not mandatory, as we\u2019ve seen this same function be executed with only the first two just a few words back in this post."}, {"a36b": "Trump is really\u00a0amazed"}, {"3fab": "If you have any question about the query execution part, please have a look at GraphQL\u2019s official documentation on query execution."}, {"5880": "We can now use the client as we normally would:"}, {"046a": "Time for one final checkpoint: 5-apollo-client."}, {"6846": "Conclusion"}, {"46b8": "This is pretty much it. I hope you all found your way in this wandering of GraphQL learning, and above all, I hope you are now able to start using GraphQL today, no more excuses allowed."}, {"369e": "Post credit\u00a0scene"}, {"57d8": "Ok, if you are really just starting with GraphQL you might not even know what to do with this ApolloClient we\u2019ve ended up with. Our index.js is still just resolving a single query. My bad. I understand that if you are here you probably already use some framework such as React, Meteor, Angular, or even Vue (but only if you are a true hipster). If that\u2019s the case, here are the libraries you are looking for:"}, {"b966": "See ya!"}, {"850b": "Originally published at taller.net.br."}], "child": "459_1\t459_2459_1\t459_2459_1\t459_2459_1\t459_2"}