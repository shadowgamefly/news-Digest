{"child": "2400_1\t2400_2\t2400_3\t2400_4\t2400_5\t2400_6\t2400_7\t2400_8\t2400_9\t2400_10\t2400_11\t2400_12\t2400_13\t2400_14\t2400_15\t2400_16\t2400_17\t2400_18\t2400_19\t2400_20\t2400_21\t2400_22\t2400_23\t2400_24\t2400_252400_1\t2400_2\t2400_3\t2400_4\t2400_5\t2400_6\t2400_7\t2400_8\t2400_9\t2400_10\t2400_11\t2400_12\t2400_13\t2400_14\t2400_15\t2400_16\t2400_17\t2400_18\t2400_19\t2400_20\t2400_21\t2400_22\t2400_23\t2400_24\t2400_25", "content": "Yes, React is taking over front-end development. The question is\u00a0why. Here are a few reasons why React has become so popular so quickly: But there\u2019s a lot more to it than just that. Let\u2019s attempt to cover all the reasons behind React\u2019s rising popularity. One reason is its Virtual DOM (React\u2019s reconciliation algorithm). We\u2019ll work through an example to show the actual practical value of having such an algorithm at your command. React\u2019s official definition states that it\u2019s a JavaScript library for building User Interfaces. It\u2019s important to understand the two different parts of this definition: Since Web browsers understand JavaScript, we can use React to describe Web User Interfaces. I like to use the word describe here because that\u2019s what we basically do with React, we just tell it what we want and React will build the actual User Interfaces, on our behalf, in the Web browser. Without React or similar libraries, we would need to manually build User Interfaces with native Web APIs and JavaScript. When you hear the statement that \u201cReact is declarative,\u201d this is exactly what it means, we describe User Interfaces with React and tell it what we want (not how to do it). React will take care of the \u201chow\u201d and translate our declarative descriptions (which we write in the React language) to actual User Interfaces in the browser. React shares this simple declarative power with HTML itself, but with React, we get to be declarative for HTML interfaces that represent dynamic data, not just static data. React has three main design concepts that drive its popularity: 1\u200a\u2014\u200aThe use of reusable, composable, and stateful components In React, we describe User Interfaces using components. You can think of components as simple functions (in any programming language). We call functions with some input and they give us some output. We can reuse functions as needed and compose bigger functions from smaller ones. Components are exactly the same; we call their input \u201cproperties\u201d and \u201cstate\u201d, and a component output is a description of a User Interface (which is similar to HTML for browsers). We can reuse a single component in multiple User Interfaces, and components can contain other components. Unlike pure functions however, a full React component can have a private state to hold data that may change over time. 2\u200a\u2014\u200aThe nature of reactive\u00a0updates React\u2019s name is the simple explanation for this concept. When the state of a component (the input) changes, the User Interface it represents (the output) changes as well. This change in the description of the User Interface has to be reflected in the device we\u2019re working with. In a browser, we need to regenerate the HTML views in the Document Object Model (DOM). With React, we do not need to worry about how to reflect these changes, or even manage when to take changes to the browser; React will simply react to the state changes and automatically update the DOM when needed. 3\u200a\u2014\u200aThe virtual representation of views in\u00a0memory With React, we write HTML using JavaScript. We rely on the power of JavaScript to generate HTML that depends on some data, rather than enhancing HTML to make it work with that data. Enhancing HTML is what other JavaScript frameworks usually do. For example, Angular extends HTML with features like loops, conditionals, and others. When we receive just the data from the server (in the background, with AJAX), we need something more than HTML to work with that data. It\u2019s either using an enhanced HTML, or using the power of JavaScript itself to generate the HTML. Both approaches have advantages and disadvantages. React embraces the latter one, with the argument that the advantages are stronger than the disadvantages. In fact, there is one major advantage that can make the case for this approach by itself; using JavaScript to render HTML makes it easy for React to keep a virtual representation of HTML in memory (which is commonly known as The Virtual DOM). React uses the Virtual DOM to render an HTML tree virtually first, and then, every time a state changes and we get a new HTML tree that needs to be taken to the browser\u2019s DOM, instead of writing the whole new tree React will only write the difference between the new tree and the previous tree (since React has both trees in memory). This process is known as Tree Reconciliation, and I think, it is the best thing that has happened in Web Development since AJAX! In the following example, we\u2019ll focus on this last concept and see a simple practical example of the tree reconciliation process and the big difference it makes. We\u2019ll write the same HTML example twice, first using native Web APIs and vanilla JavaScript, and then we\u2019ll see how to describe the same HTML tree with React. To purely focus on this last concept, we will not be using components, and we will mock a state change operation using a JavaScript timer. We are also not going to use JSX, although using JSX will make for a much simpler code. I use JSX all the time when I write React, but working with React API directly in this example will hopefully make you understand this concept much better. React\u2019s reconciliation algorithm example To follow along with this example, you need a browser and a code editor. You can actually use an online coding playground, but I\u2019ll use local files and test them directly in a browser (we don\u2019t need a web server): We\u2019ll start this example from scratch. Create a new directory, and launch your favorite editor there: mkdir react-democd react-demoatom . Create an index.html file in that directory, and put a standard HTML template in there. Include in that template a script.js file and put a console.log statement in that script to test that the include works: <!DOCTYPE html><html>  <head>    <meta charset=\"utf-8\">    <title>React Demo</title>  </head>  <body>    <script src=\"script.js\"></script>  </body></html> Open the index.html file in your browser and make sure you can see the empty template without problems, and that you can see in the Console dev-tools tab the console.log test message that you put in script.js: open index.html # On Macexplorer index.html # On Windows Now, let\u2019s bring in the React library itself, which we can include from the Reactjs website. Copy both the react and react-dom scripts, and include them in index.html: <script src=\"https://unpkg.com/react@15/dist/react.js\"></script> <script src=\"https://unpkg.com/react-dom@15/dist/react-dom.js\"></script> We\u2019re including two different scripts here for an important reason: The React library itself can be used without a browser. To use React with a browser, we need the ReactDOM library. When we refresh the browser now, we should see both React and ReactDOM available on the global scope: Image captured in\u00a0Chrome With this simple setup, we can now access both React and ReactDOM APIs, and of course, we also have access to the native Web APIs and JavaScript which we are going to use first. To insert HTML dynamically in the browser we can simply use pure JavaScript and the DOM Web API itself. Let\u2019s create a div element to host our JavaScript HTML content and give it the id \"js\". In the body element of index.html, right before the script tag, add: <div id=\"js\"></div> Now in script.js, let's grab this new div element by its id and put it in a constant. Let's name this constant jsContainer. We can use document.getElementById to grab the div from HTML: const jsContainer = document.getElementById(\"js\"); To control the content of this div, we can use the innerHTML setter call on the div element directly. We can use this call to supply any HTML template that we want inserted in the DOM. Let's insert a div element with a class of \"demo\" and the string \"Hello JS\" as its content: jsContainer.innerHTML = `  <div class=\"demo\">    Hello JS  </div>`; Make sure this works in the browser. You should see the \u201cHello JS\u201d line on the screen now. This demo div is our User Interface so far. It\u2019s a very simple one. We just output a text for the user to see. Both document.getElementById and element.innerHTML are actually part of the native DOM Web API. We are communicating with the browser directly here using the supported APIs of the Web platform. When we write React code, however, we use the React API instead, and we let React communicate with the browser using the DOM Web API. React acts like our agent for the browser, and we mostly need to communicate with just React, our agent, and not the browser itself. I say mostly because there are cases where we still need to communicate with the browser, but those are rare. To create the exact same User Interface that we have so far but with React API this time, let\u2019s create another div element and give it an id of \"react\". In index.html, right under the div#js element, add: <div id=\"react\"></div> Now, in script.js, create a new container constant for the new div: const reactContainer = document.getElementById(\"react\"); This container will be the only call we make to the native web API. ReactDOM needs this container to know where to host our application in the DOM. With the react container identified, we can now use the ReactDOM library to render React's version of the HTML template to this container: ReactDOM.render(  /* TODO: React's version of the HTML template */,  reactContainer) What we\u2019re going to do next is your first milestone in truly understanding the React library. Remember when I told you that with React we write HTML using JavaScript? This is exactly what we are going to do next. To write our simple HTML User Interface, we are going to use JavaScript calls to React API, and by the end of the example you\u2019ll have a better picture about the reason for doing so. Instead of working with strings (as we did in the native JavaScript example above), in React, we work with objects. Any HTML string will be represented as an object using a React.createElement call (which is the core function in the React API). Here\u2019s the equivalent HTML User Interface we have so far with React: ReactDOM.render(    React.createElement(      \"div\",      { className: \"demo\" },      \"Hello React\"    ),    reactContainer  ); React.createElement has many arguments: We can test this now. The browser should render both \u201cHello JS\u201d and \u201cHello React\u201d. Let\u2019s style the demo divs as a box, using this CSS, just so that we can visually split the screen. In index.html: <style media=\"screen\">  .demo {    border: 1px solid #ccc;    margin: 1em;    padding: 1em;  }</style> Image captured in\u00a0Chrome We now have two nodes, one being controlled with the DOM Web API directly, and another being controlled with the React API (which in turn uses the DOM Web API). The only major difference between the ways we are building these two nodes in the browser is that in the JS version we used a string to represent the content, while in the React version we used pure JavaScript calls and represented the content with an object instead of a string. No matter how complicated the HTML User Interface is going to get, when using React, every HTML element will be represented with a JavaScript object using a React.createElement call. Let\u2019s now add some more features to our simple User Interface. Let\u2019s add a text box to read input from the user. To nest elements in our HTML template, it\u2019s straight forward in the JS version because it\u2019s just HTML. For example, to make the demo div render an <input /> element, we simply add it to the content: jsContainer.innerHTML = `  <div class=\"demo\">    Hello JS    <input />  </div>`; We can do the same with React by adding more arguments after the 3rd argument for React.createElement. To match what we did in the native JS example, we can add a 4th argument that is another React.createElement call that renders an input element (remember, every HTML element is an object): ReactDOM.render(  React.createElement(    \"div\",    { className: \"demo\" },    \"Hello React\",    React.createElement(\"input\")  ),  reactContainer); At this point, if you\u2019re questioning what we\u2019re doing and thinking \u201cthis is complicating a simple process\u201d, you are totally right! But there is a very good reason for what we\u2019re doing. Keep reading. Let\u2019s also render a timestamp in both versions. In the JS version, let\u2019s put the timestamp in a paragraph element. We can use a call to new Date() to display a simple timestamp: jsContainer.innerHTML = `  <div class=\"demo\">    Hello JS    <input />    <p>${new Date()}</p>  </div>`; To do the same in React, we add a 5th argument to the top-level div element. This new 5th argument is another React.createElement call, this time using a p tag, with no attributes, and the new Date() string for content: ReactDOM.render(  React.createElement(    \"div\",    { className: \"demo\" },    \"Hello React\",    React.createElement(\"input\"),    React.createElement(      \"p\",      null,      new Date().toString()    )  ),  reactContainer); Both JS and React versions are still rendering the exact same HTML in the browser. Image captured in\u00a0Chrome As you can see, so far, using React is actually a lot harder than the simple and familiar native way. What is it that React does so well that\u2019s worth giving up the familiar HTML and having to learn a new API to write what can be simply written in HTML? The answer is not about rendering the first HTML view, it\u2019s about what we need to do to update any existing view in the DOM. So, let\u2019s do an update operation on the DOM we have so far. Let\u2019s simply make the timestamp tick every second. We can easily repeat a JavaScript function call in a browser using the setInterval Web timer API. So, let's put all of our DOM manipulations for both JS and React versions in a function, call it render, and use it in a setInterval call to make it repeat every second. Here\u2019s the full final code in script.js: const jsContainer = document.getElementById(\"js\");const reactContainer = document.getElementById(\"react\"); const render = () => {  jsContainer.innerHTML = `    <div class=\"demo\">      Hello JS      <input />      <p>${new Date()}</p>    </div>  `; ReactDOM.render(    React.createElement(      \"div\",      { className: \"demo\" },      \"Hello React \",      React.createElement(\"input\"),      React.createElement(        \"p\",        null,        new Date().toString()      )    ),    reactContainer  );} setInterval(render, 1000); When we refresh the browser now, the timestamp string should be ticking every second in both versions. We are now updating our User Interface in the DOM. This is the moment when React will potentially blow your mind. If you try to type something in the text box of the JS version, you won\u2019t be able to. This is very much expected because we\u2019re basically throwing away the whole DOM node on every tick and regenerating it. However, if you try to type something in the text box that\u2019s rendered with React, you can certainly do so! Although the whole React rendering code is within our ticking timer, React is changing only the timestamp paragraph and not the whole DOM node. This is why the text input box was not regenerated and we were able to type in it. You can see the different ways we\u2019re updating the DOM visually if you inspect the two DOM nodes in a Chrome dev tools elements panel. The Chrome div tools highlights any HTML elements that get updated. You\u2019ll see how we are regenerating the whole \u201cjs\u201d div on every tick, while React is smartly only regenerating the paragraph with the timestamp string. Image captured in\u00a0Chrome React has a smart diffing algorithm that it uses to only regenerate in its DOM node what actually needs to be regenerated while it keeps everything else as is. This diffing process is possible because of React\u2019s virtual DOM and the fact that we have a representation of our User Interface in memory (because we wrote in JavaScript). Using the virtual DOM, React keeps the last DOM version in memory and when it has a new DOM version to take to the browser, that new DOM version will also be in memory, so React can compute the difference between the new and the old versions (in our case, the difference is the timestamp paragraph). React will then instruct the browser to update only the computed diff and not the whole DOM node. No matter how many times we regenerate our interface, React will take to the browser only the new \u201cpartial\u201d updates. Not only is this method a lot more efficient, but it also removes a big layer of complexity for the way we think about updating User Interfaces. Having React do all the computations about whether we should update the DOM or not enables us to focus on thinking about our data (state) and the way to describe a User Interface for it. We then manage the updates on our data as needed without worrying about the steps needed to reflect these updates on the actual User Interface in the browser (because we know React will do exactly that and it will do that in an efficient way!) Thanks for reading! You can view the source code of my demo here, and you can see the demo running here. If you have any questions about this article or any other article I wrote, find me on this slack account (you can invite yourself) and ask in the #questions room. I create online courses for Pluralsight and Lynda. My most recent courses are Getting Started with React.js, Advanced Node.js, and Learning Full-stack JavaScript. ", "title": "Yes, React is taking over front-end development. The question is\u00a0why.", "sentences": [{"2f48": "Yes, React is taking over front-end development. The question is\u00a0why."}, {"bf8c": "Here are a few reasons why React has become so popular so quickly:"}, {"2be1": "But there\u2019s a lot more to it than just that. Let\u2019s attempt to cover all the reasons behind React\u2019s rising popularity. One reason is its Virtual DOM (React\u2019s reconciliation algorithm). We\u2019ll work through an example to show the actual practical value of having such an algorithm at your command."}, {"5149": "React\u2019s official definition states that it\u2019s a JavaScript library for building User Interfaces. It\u2019s important to understand the two different parts of this definition:"}, {"f46e": "Since Web browsers understand JavaScript, we can use React to describe Web User Interfaces. I like to use the word describe here because that\u2019s what we basically do with React, we just tell it what we want and React will build the actual User Interfaces, on our behalf, in the Web browser. Without React or similar libraries, we would need to manually build User Interfaces with native Web APIs and JavaScript."}, {"1fc6": "When you hear the statement that \u201cReact is declarative,\u201d this is exactly what it means, we describe User Interfaces with React and tell it what we want (not how to do it). React will take care of the \u201chow\u201d and translate our declarative descriptions (which we write in the React language) to actual User Interfaces in the browser. React shares this simple declarative power with HTML itself, but with React, we get to be declarative for HTML interfaces that represent dynamic data, not just static data."}, {"6057": "React has three main design concepts that drive its popularity:"}, {"f2ee": "1\u200a\u2014\u200aThe use of reusable, composable, and stateful components"}, {"c3fd": "In React, we describe User Interfaces using components. You can think of components as simple functions (in any programming language). We call functions with some input and they give us some output. We can reuse functions as needed and compose bigger functions from smaller ones."}, {"cfaa": "Components are exactly the same; we call their input \u201cproperties\u201d and \u201cstate\u201d, and a component output is a description of a User Interface (which is similar to HTML for browsers). We can reuse a single component in multiple User Interfaces, and components can contain other components."}, {"e6ee": "Unlike pure functions however, a full React component can have a private state to hold data that may change over time."}, {"ce3a": "2\u200a\u2014\u200aThe nature of reactive\u00a0updates"}, {"3503": "React\u2019s name is the simple explanation for this concept. When the state of a component (the input) changes, the User Interface it represents (the output) changes as well. This change in the description of the User Interface has to be reflected in the device we\u2019re working with."}, {"3302": "In a browser, we need to regenerate the HTML views in the Document Object Model (DOM). With React, we do not need to worry about how to reflect these changes, or even manage when to take changes to the browser; React will simply react to the state changes and automatically update the DOM when needed."}, {"9451": "3\u200a\u2014\u200aThe virtual representation of views in\u00a0memory"}, {"5e0f": "With React, we write HTML using JavaScript. We rely on the power of JavaScript to generate HTML that depends on some data, rather than enhancing HTML to make it work with that data. Enhancing HTML is what other JavaScript frameworks usually do. For example, Angular extends HTML with features like loops, conditionals, and others."}, {"898a": "When we receive just the data from the server (in the background, with AJAX), we need something more than HTML to work with that data. It\u2019s either using an enhanced HTML, or using the power of JavaScript itself to generate the HTML. Both approaches have advantages and disadvantages. React embraces the latter one, with the argument that the advantages are stronger than the disadvantages."}, {"2c15": "In fact, there is one major advantage that can make the case for this approach by itself; using JavaScript to render HTML makes it easy for React to keep a virtual representation of HTML in memory (which is commonly known as The Virtual DOM). React uses the Virtual DOM to render an HTML tree virtually first, and then, every time a state changes and we get a new HTML tree that needs to be taken to the browser\u2019s DOM, instead of writing the whole new tree React will only write the difference between the new tree and the previous tree (since React has both trees in memory). This process is known as Tree Reconciliation, and I think, it is the best thing that has happened in Web Development since AJAX!"}, {"07cf": "In the following example, we\u2019ll focus on this last concept and see a simple practical example of the tree reconciliation process and the big difference it makes. We\u2019ll write the same HTML example twice, first using native Web APIs and vanilla JavaScript, and then we\u2019ll see how to describe the same HTML tree with React."}, {"c8a0": "To purely focus on this last concept, we will not be using components, and we will mock a state change operation using a JavaScript timer. We are also not going to use JSX, although using JSX will make for a much simpler code. I use JSX all the time when I write React, but working with React API directly in this example will hopefully make you understand this concept much better."}, {"5302": "React\u2019s reconciliation algorithm example"}, {"5ed3": "To follow along with this example, you need a browser and a code editor. You can actually use an online coding playground, but I\u2019ll use local files and test them directly in a browser (we don\u2019t need a web server):"}, {"2ec9": "We\u2019ll start this example from scratch. Create a new directory, and launch your favorite editor there:"}, {"68bd": "mkdir react-democd react-demoatom ."}, {"6151": "Create an index.html file in that directory, and put a standard HTML template in there. Include in that template a script.js file and put a console.log statement in that script to test that the include works:"}, {"8366": "<!DOCTYPE html><html>  <head>    <meta charset=\"utf-8\">    <title>React Demo</title>  </head>  <body>    <script src=\"script.js\"></script>  </body></html>"}, {"ebba": "Open the index.html file in your browser and make sure you can see the empty template without problems, and that you can see in the Console dev-tools tab the console.log test message that you put in script.js:"}, {"3032": "open index.html # On Macexplorer index.html # On Windows"}, {"b2c4": "Now, let\u2019s bring in the React library itself, which we can include from the Reactjs website. Copy both the react and react-dom scripts, and include them in index.html:"}, {"e13d": "<script src=\"https://unpkg.com/react@15/dist/react.js\"></script> <script src=\"https://unpkg.com/react-dom@15/dist/react-dom.js\"></script>"}, {"bb8a": "We\u2019re including two different scripts here for an important reason: The React library itself can be used without a browser. To use React with a browser, we need the ReactDOM library."}, {"f575": "When we refresh the browser now, we should see both React and ReactDOM available on the global scope:"}, {"7f22": "Image captured in\u00a0Chrome"}, {"84b6": "With this simple setup, we can now access both React and ReactDOM APIs, and of course, we also have access to the native Web APIs and JavaScript which we are going to use first."}, {"34cd": "To insert HTML dynamically in the browser we can simply use pure JavaScript and the DOM Web API itself. Let\u2019s create a div element to host our JavaScript HTML content and give it the id \"js\". In the body element of index.html, right before the script tag, add:"}, {"0b4e": "<div id=\"js\"></div>"}, {"ab24": "Now in script.js, let's grab this new div element by its id and put it in a constant. Let's name this constant jsContainer. We can use document.getElementById to grab the div from HTML:"}, {"c48b": "const jsContainer = document.getElementById(\"js\");"}, {"bfb2": "To control the content of this div, we can use the innerHTML setter call on the div element directly. We can use this call to supply any HTML template that we want inserted in the DOM. Let's insert a div element with a class of \"demo\" and the string \"Hello JS\" as its content:"}, {"e8bf": "jsContainer.innerHTML = `  <div class=\"demo\">    Hello JS  </div>`;"}, {"0790": "Make sure this works in the browser. You should see the \u201cHello JS\u201d line on the screen now."}, {"01ce": "This demo div is our User Interface so far. It\u2019s a very simple one. We just output a text for the user to see."}, {"aea3": "Both document.getElementById and element.innerHTML are actually part of the native DOM Web API. We are communicating with the browser directly here using the supported APIs of the Web platform. When we write React code, however, we use the React API instead, and we let React communicate with the browser using the DOM Web API."}, {"415c": "React acts like our agent for the browser, and we mostly need to communicate with just React, our agent, and not the browser itself. I say mostly because there are cases where we still need to communicate with the browser, but those are rare."}, {"209b": "To create the exact same User Interface that we have so far but with React API this time, let\u2019s create another div element and give it an id of \"react\". In index.html, right under the div#js element, add:"}, {"1ea5": "<div id=\"react\"></div>"}, {"747b": "Now, in script.js, create a new container constant for the new div:"}, {"8d47": "const reactContainer = document.getElementById(\"react\");"}, {"b957": "This container will be the only call we make to the native web API. ReactDOM needs this container to know where to host our application in the DOM."}, {"3f2b": "With the react container identified, we can now use the ReactDOM library to render React's version of the HTML template to this container:"}, {"9a7d": "ReactDOM.render(  /* TODO: React's version of the HTML template */,  reactContainer)"}, {"f2b7": "What we\u2019re going to do next is your first milestone in truly understanding the React library. Remember when I told you that with React we write HTML using JavaScript? This is exactly what we are going to do next."}, {"2a4d": "To write our simple HTML User Interface, we are going to use JavaScript calls to React API, and by the end of the example you\u2019ll have a better picture about the reason for doing so."}, {"8df6": "Instead of working with strings (as we did in the native JavaScript example above), in React, we work with objects. Any HTML string will be represented as an object using a React.createElement call (which is the core function in the React API)."}, {"0add": "Here\u2019s the equivalent HTML User Interface we have so far with React:"}, {"bd8e": "ReactDOM.render(    React.createElement(      \"div\",      { className: \"demo\" },      \"Hello React\"    ),    reactContainer  );"}, {"d512": "React.createElement has many arguments:"}, {"0532": "We can test this now. The browser should render both \u201cHello JS\u201d and \u201cHello React\u201d. Let\u2019s style the demo divs as a box, using this CSS, just so that we can visually split the screen. In index.html:"}, {"83ef": "<style media=\"screen\">  .demo {    border: 1px solid #ccc;    margin: 1em;    padding: 1em;  }</style>"}, {"dfed": "Image captured in\u00a0Chrome"}, {"4743": "We now have two nodes, one being controlled with the DOM Web API directly, and another being controlled with the React API (which in turn uses the DOM Web API). The only major difference between the ways we are building these two nodes in the browser is that in the JS version we used a string to represent the content, while in the React version we used pure JavaScript calls and represented the content with an object instead of a string."}, {"26c3": "No matter how complicated the HTML User Interface is going to get, when using React, every HTML element will be represented with a JavaScript object using a React.createElement call."}, {"b386": "Let\u2019s now add some more features to our simple User Interface. Let\u2019s add a text box to read input from the user."}, {"3241": "To nest elements in our HTML template, it\u2019s straight forward in the JS version because it\u2019s just HTML. For example, to make the demo div render an <input /> element, we simply add it to the content:"}, {"b6bd": "jsContainer.innerHTML = `  <div class=\"demo\">    Hello JS    <input />  </div>`;"}, {"3da3": "We can do the same with React by adding more arguments after the 3rd argument for React.createElement. To match what we did in the native JS example, we can add a 4th argument that is another React.createElement call that renders an input element (remember, every HTML element is an object):"}, {"6b97": "ReactDOM.render(  React.createElement(    \"div\",    { className: \"demo\" },    \"Hello React\",    React.createElement(\"input\")  ),  reactContainer);"}, {"f6e7": "At this point, if you\u2019re questioning what we\u2019re doing and thinking \u201cthis is complicating a simple process\u201d, you are totally right! But there is a very good reason for what we\u2019re doing. Keep reading."}, {"ffd8": "Let\u2019s also render a timestamp in both versions. In the JS version, let\u2019s put the timestamp in a paragraph element. We can use a call to new Date() to display a simple timestamp:"}, {"25f3": "jsContainer.innerHTML = `  <div class=\"demo\">    Hello JS    <input />    <p>${new Date()}</p>  </div>`;"}, {"0810": "To do the same in React, we add a 5th argument to the top-level div element. This new 5th argument is another React.createElement call, this time using a p tag, with no attributes, and the new Date() string for content:"}, {"94e6": "ReactDOM.render(  React.createElement(    \"div\",    { className: \"demo\" },    \"Hello React\",    React.createElement(\"input\"),    React.createElement(      \"p\",      null,      new Date().toString()    )  ),  reactContainer);"}, {"57af": "Both JS and React versions are still rendering the exact same HTML in the browser."}, {"90fd": "Image captured in\u00a0Chrome"}, {"8df0": "As you can see, so far, using React is actually a lot harder than the simple and familiar native way. What is it that React does so well that\u2019s worth giving up the familiar HTML and having to learn a new API to write what can be simply written in HTML? The answer is not about rendering the first HTML view, it\u2019s about what we need to do to update any existing view in the DOM."}, {"bf87": "So, let\u2019s do an update operation on the DOM we have so far. Let\u2019s simply make the timestamp tick every second."}, {"46de": "We can easily repeat a JavaScript function call in a browser using the setInterval Web timer API. So, let's put all of our DOM manipulations for both JS and React versions in a function, call it render, and use it in a setInterval call to make it repeat every second."}, {"5631": "Here\u2019s the full final code in script.js:"}, {"1e98": "const jsContainer = document.getElementById(\"js\");const reactContainer = document.getElementById(\"react\");"}, {"75ae": "const render = () => {  jsContainer.innerHTML = `    <div class=\"demo\">      Hello JS      <input />      <p>${new Date()}</p>    </div>  `;"}, {"2fee": "ReactDOM.render(    React.createElement(      \"div\",      { className: \"demo\" },      \"Hello React \",      React.createElement(\"input\"),      React.createElement(        \"p\",        null,        new Date().toString()      )    ),    reactContainer  );}"}, {"cf04": "setInterval(render, 1000);"}, {"ec3d": "When we refresh the browser now, the timestamp string should be ticking every second in both versions. We are now updating our User Interface in the DOM."}, {"cef1": "This is the moment when React will potentially blow your mind. If you try to type something in the text box of the JS version, you won\u2019t be able to. This is very much expected because we\u2019re basically throwing away the whole DOM node on every tick and regenerating it. However, if you try to type something in the text box that\u2019s rendered with React, you can certainly do so!"}, {"8731": "Although the whole React rendering code is within our ticking timer, React is changing only the timestamp paragraph and not the whole DOM node. This is why the text input box was not regenerated and we were able to type in it."}, {"c43f": "You can see the different ways we\u2019re updating the DOM visually if you inspect the two DOM nodes in a Chrome dev tools elements panel. The Chrome div tools highlights any HTML elements that get updated. You\u2019ll see how we are regenerating the whole \u201cjs\u201d div on every tick, while React is smartly only regenerating the paragraph with the timestamp string."}, {"1bb8": "Image captured in\u00a0Chrome"}, {"568a": "React has a smart diffing algorithm that it uses to only regenerate in its DOM node what actually needs to be regenerated while it keeps everything else as is. This diffing process is possible because of React\u2019s virtual DOM and the fact that we have a representation of our User Interface in memory (because we wrote in JavaScript)."}, {"10f3": "Using the virtual DOM, React keeps the last DOM version in memory and when it has a new DOM version to take to the browser, that new DOM version will also be in memory, so React can compute the difference between the new and the old versions (in our case, the difference is the timestamp paragraph)."}, {"e8f1": "React will then instruct the browser to update only the computed diff and not the whole DOM node. No matter how many times we regenerate our interface, React will take to the browser only the new \u201cpartial\u201d updates."}, {"7dd5": "Not only is this method a lot more efficient, but it also removes a big layer of complexity for the way we think about updating User Interfaces. Having React do all the computations about whether we should update the DOM or not enables us to focus on thinking about our data (state) and the way to describe a User Interface for it."}, {"1ac6": "We then manage the updates on our data as needed without worrying about the steps needed to reflect these updates on the actual User Interface in the browser (because we know React will do exactly that and it will do that in an efficient way!)"}, {"1ceb": "Thanks for reading! You can view the source code of my demo here, and you can see the demo running here."}, {"9c09": "If you have any questions about this article or any other article I wrote, find me on this slack account (you can invite yourself) and ask in the #questions room."}, {"ccac": "I create online courses for Pluralsight and Lynda. My most recent courses are Getting Started with React.js, Advanced Node.js, and Learning Full-stack JavaScript."}], "name": "2400", "parent": ""}