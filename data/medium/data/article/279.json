{"name": "279", "parent": "", "content": "How to double your engagement by tweaking your technology stack Our team began implementing Service Oriented Architecture (SOA) almost a year ago, and we have already felt the advantages of this approach. SOA helps us to decouple application features, make Smartling more API friendly and our whole system more fail-safe. Now a failure in a single service will not result in platform downtime, and it is much easier to find and fix problems in a separate service. The whole development team now sleeps much better. However, this article is not about SOA, but about an experiment to create a whole new product as a service. We wanted to create a lightweight application for people who need translations fast and easy. There should be a simple flow: upload files, pay for translation, download files when translations are ready. The goal was to quickly build a simple prototype to get feedback from users. Ninety percent of the prototype was front-end, using the existing API from other parts of the system to minimize development effort. One of the advantages of creating separate services is how much easier it is to try something new. Not being tied to your old codebase and infrastructure gives you more options. So we decided to try a single page application. It was a reasonable decision, as our back-end was supposed to be minimal. To make thing faster, we used a familiar stack: Marionette, require.js and Grunt. Basically, the application was built of packages that were noted in the require-config.js: packages: [    {        name: \u201cmain\u201d,        main: \u201cmain\u201d,        location: \u201capp/main\u201d    },    {        name: \u201corders\u201d,        main: \u201cmain\u201d,        location: \u201capp/orders\u201d    },    {        name: \u201cregistration\u201d,        main: \u201cmain\u201d,        location: \u201capp/registration\u201d    }    \u2026] The entire application was built with the r.js tool in a single file. To configure r.js we used a build.json file similar to the docs example: ({    appDir: \u201c../\u201d,    baseUrl: \u201cscripts\u201d,    dir: \u201c../../appdirectory-build\u201d,    modules: [        {            name: \u201cmain\u201d        }    ]}) The main package handles application level tasks: All other packages are imported by the main package and instantiated when needed. We needed to support a few start up flows for our front-end application. For example: Load Scripts \u2192 Check Auth \u2192 Not Logged In \u2192 Sign in \u2192 Get Context \u2192 Instantiate \u2018orders\u2019 Load Script \u2192 Check Auth \u2192 Not Logged In \u2192 Instantiate registration \u2192 Get Context \u2192 Instantiate \u2018orders\u2019 Load Script \u2192 Check Auth \u2192 Logged In \u2192Instantiate \u2018orders\u2019 When we completed the first version of the app, we added a few libraries to track events\u200a\u2014\u200aTrackjs, Mixpanel, Google Analytics. We also used Fullstory to analyse user behaviour. Then we created a fancy landing page, complete with FAQ and a prominent Upload button. Done-done! We deployed the application so the business stakeholders could begin to gather feedback. From our perspective, everything was fine. The webapp seemed light and fast, it had its own landing page, so the user was able to start using it without any redirects. But engagement data surprised us. Many visitors closed the page before it even finished loading. We didn\u2019t show the landing page before the app was initialised, and depending on a visitor\u2019s connection speed, this could take a few seconds. Turns out, these few seconds cost us half of our potential users. We started to search for a way to speed up the page load. The \u2018heaviest\u2019 part of the page was scripts. These were already minified and built into a single file, but it was not enough, so we decided to split scripts into multiple files and defer their load. As our application was already split into packages, this wasn\u2019t so hard. Initially we load only one main package that does not explicitly depend on other packages. Now, when we need to instantiate code from some other package we have to require it first: require([\u201corders\u201d], function(Orders){    var controller = new Orders(config);}) Also, we had to adjust our build script to generate separate files for each package, instead of a single file for the application. To do so we needed to change the modules option in our build.json: modules: [    {        name: \"main\"    },    {        name: \"orders\",        exclude: [\"main\"]    }    ...] We need an exclude option here, to prevent including the same dependencies in different files. For example, if jquery is included in main, it wouldn\u2019t be included in orders even if orders depends on it. Even when we migrated to webpack there was no need to configure anything, webpack recognizes the require statements and creates a separate bundle file during build. These changes slightly improved page load speed. But it still wasn\u2019t enough. So we made the decision to show a landing page as soon as it was available and load scripts in background. This approach created a better user experience which was verifiable from improved engagement and funnel analytics. So don\u2019t forget that no matter how fancy your single page application approach is, it\u2019s no good if your users get tired of waiting for it. Don\u2019t test their patience! ", "title": "How to double your engagement by tweaking your technology stack", "sentences": [{"942e": "How to double your engagement by tweaking your technology stack"}, {"940b": "Our team began implementing Service Oriented Architecture (SOA) almost a year ago, and we have already felt the advantages of this approach. SOA helps us to decouple application features, make Smartling more API friendly and our whole system more fail-safe. Now a failure in a single service will not result in platform downtime, and it is much easier to find and fix problems in a separate service. The whole development team now sleeps much better."}, {"92d3": "However, this article is not about SOA, but about an experiment to create a whole new product as a service. We wanted to create a lightweight application for people who need translations fast and easy. There should be a simple flow: upload files, pay for translation, download files when translations are ready. The goal was to quickly build a simple prototype to get feedback from users. Ninety percent of the prototype was front-end, using the existing API from other parts of the system to minimize development effort."}, {"6886": "One of the advantages of creating separate services is how much easier it is to try something new. Not being tied to your old codebase and infrastructure gives you more options. So we decided to try a single page application. It was a reasonable decision, as our back-end was supposed to be minimal. To make thing faster, we used a familiar stack: Marionette, require.js and Grunt."}, {"5044": "Basically, the application was built of packages that were noted in the require-config.js:"}, {"619f": "packages: [    {        name: \u201cmain\u201d,        main: \u201cmain\u201d,        location: \u201capp/main\u201d    },    {        name: \u201corders\u201d,        main: \u201cmain\u201d,        location: \u201capp/orders\u201d    },    {        name: \u201cregistration\u201d,        main: \u201cmain\u201d,        location: \u201capp/registration\u201d    }    \u2026]"}, {"e4fa": "The entire application was built with the r.js tool in a single file. To configure r.js we used a build.json file similar to the docs example:"}, {"bca8": "({    appDir: \u201c../\u201d,    baseUrl: \u201cscripts\u201d,    dir: \u201c../../appdirectory-build\u201d,    modules: [        {            name: \u201cmain\u201d        }    ]})"}, {"278a": "The main package handles application level tasks:"}, {"72fe": "All other packages are imported by the main package and instantiated when needed."}, {"065f": "We needed to support a few start up flows for our front-end application. For example:"}, {"33bc": "Load Scripts \u2192 Check Auth \u2192 Not Logged In \u2192 Sign in \u2192 Get Context \u2192 Instantiate \u2018orders\u2019"}, {"0e48": "Load Script \u2192 Check Auth \u2192 Not Logged In \u2192 Instantiate registration \u2192 Get Context \u2192 Instantiate \u2018orders\u2019"}, {"4cae": "Load Script \u2192 Check Auth \u2192 Logged In \u2192Instantiate \u2018orders\u2019"}, {"824a": "When we completed the first version of the app, we added a few libraries to track events\u200a\u2014\u200aTrackjs, Mixpanel, Google Analytics. We also used Fullstory to analyse user behaviour. Then we created a fancy landing page, complete with FAQ and a prominent Upload button. Done-done! We deployed the application so the business stakeholders could begin to gather feedback."}, {"3a1a": "From our perspective, everything was fine. The webapp seemed light and fast, it had its own landing page, so the user was able to start using it without any redirects."}, {"1665": "But engagement data surprised us. Many visitors closed the page before it even finished loading. We didn\u2019t show the landing page before the app was initialised, and depending on a visitor\u2019s connection speed, this could take a few seconds. Turns out, these few seconds cost us half of our potential users."}, {"ea6c": "We started to search for a way to speed up the page load. The \u2018heaviest\u2019 part of the page was scripts. These were already minified and built into a single file, but it was not enough, so we decided to split scripts into multiple files and defer their load."}, {"6bfb": "As our application was already split into packages, this wasn\u2019t so hard. Initially we load only one main package that does not explicitly depend on other packages. Now, when we need to instantiate code from some other package we have to require it first:"}, {"d6ce": "require([\u201corders\u201d], function(Orders){    var controller = new Orders(config);})"}, {"1b6b": "Also, we had to adjust our build script to generate separate files for each package, instead of a single file for the application. To do so we needed to change the modules option in our build.json:"}, {"7667": "modules: [    {        name: \"main\"    },    {        name: \"orders\",        exclude: [\"main\"]    }    ...]"}, {"cdbd": "We need an exclude option here, to prevent including the same dependencies in different files. For example, if jquery is included in main, it wouldn\u2019t be included in orders even if orders depends on it. Even when we migrated to webpack there was no need to configure anything, webpack recognizes the require statements and creates a separate bundle file during build."}, {"176e": "These changes slightly improved page load speed. But it still wasn\u2019t enough. So we made the decision to show a landing page as soon as it was available and load scripts in background. This approach created a better user experience which was verifiable from improved engagement and funnel analytics."}, {"6b1f": "So don\u2019t forget that no matter how fancy your single page application approach is, it\u2019s no good if your users get tired of waiting for it. Don\u2019t test their patience!"}], "child": "279_1"}