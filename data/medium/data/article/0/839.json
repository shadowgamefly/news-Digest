{"parent": "", "title": "So what\u2019s this GraphQL thing I keep hearing\u00a0about?", "author": "Sacha Greif", "sentences": [{"a2e7": "So what\u2019s this GraphQL thing I keep hearing\u00a0about?"}, {"3bc9": "If you\u2019re like me, you probably go through three stages when hearing about a new technology:"}, {"3bca": "1. Dismissal"}, {"ce06": "One more JavaScript library?! Just use jQuery already!"}, {"fc28": "2. Interest"}, {"8fb4": "Hmm, maybe I should check out this new library I keep hearing about\u2026"}, {"a919": "3. Panic"}, {"d3b1": "Help! I need to learn this new library right now or I\u2019ll be completely obsolete!"}, {"d4f2": "The trick to maintaining your sanity in these fast-moving times is to learn new stuff right between stages two and three, once your interest is piqued but while you\u2019re still ahead of the curve."}, {"a54b": "Which is why now is the perfect time to learn what exactly this GraphQL thing you keep hearing about really is."}, {"d860": "The Basics"}, {"1430": "In a nutshell, GraphQL is a syntax that describes how to ask for data, and is generally used to load data from a server to a client. GraphQL has three main characteristics:"}, {"3776": "So how did GraphQL get started? What does it look like in practice? And how do you start using it? Read on to find out!"}, {"8e97": "The Problem"}, {"a048": "GraphQL got its start at big old Facebook, but even much simpler apps can often bump into the limitations of traditional REST APIs."}, {"5ece": "For example, imagine you need to display a list of posts, and under each post a list of likes, including user names and avatars. Easy enough, you tweak your posts API to include a likes array containing user objects:"}, {"a15e": "But now, it\u2019s time to work on your mobile app, and it turns out loading all that extra data is slowing things down. So you now need two endpoints, one with the likes and one without them."}, {"2cd8": "Now add one more factor to the mix: it turns out that while posts are stored in a MySQL database, likes on the other hand live in a Redis store! What do you do now?!"}, {"4dc5": "Extrapolate this scenario to however many data sources and API clients Facebook has to manage, and you can imagine why good old REST APIs were starting to show their limits."}, {"a265": "The Solution"}, {"3099": "The solution Facebook came up with is conceptually very simple: instead of having multiple \u201cdumb\u201d endpoints, have a single \u201csmart\u201d endpoint that can take in complex queries, and then massage the data output into whatever shape the client requires."}, {"4cd3": "Practically speaking, the GraphQL layer lives between the client and one or more data sources, receiving client requests and fetching the necessary data according to your instructions. Confused? It\u2019s metaphor time!"}, {"ebed": "The old REST model is like ordering pizza, then getting groceries delivered, then calling your dry cleaner to get your clothes. Three shops, three phone calls."}, {"b000": "GraphQL on the other hand is like having a personal assistant: once you\u2019ve given them the addresses to all three places, you can simply ask for what you want (\u201cget me my dry cleaning, a large pizza, and two dozen eggs\u201d) and wait for them to return."}, {"4f3e": "In other words, GraphQL establishes a standard language for talking to this magical personal assistant."}, {"a2ba": "In practice, a GraphQL API is organized around three main building blocks: the schema, queries, and resolvers."}, {"fc35": "Queries"}, {"27ed": "The request you make to your GraphQL personal assistant is the query, and it looks something like this:"}, {"d09a": "query {  stuff}"}, {"0791": "We\u2019re declaring a new query using the query keyword, then asking for a field named stuff. The great thing about GraphQL queries is that they support nested fields, so we can go one level deeper:"}, {"fd1d": "query {  stuff {    eggs    shirt    pizza  }}"}, {"d212": "As you can see, the client making the query doesn\u2019t need to care which \u201cshop\u201d the data is coming from. Just ask for what you need, and let the GraphQL server take care of the rest."}, {"1876": "It\u2019s worth noting that query fields can also point to arrays. For example, here\u2019s a common pattern when querying for a list of posts:"}, {"eee9": "query {  posts { # this is an array    title    body    author { # we can go deeper!      name      avatarUrl      profileUrl    }  }}"}, {"130f": "Query fields also support arguments. If I want to display a specific post, I can add an id argument to the post field:"}, {"6c01": "query {  post(id: \"123foo\"){    title    body    author{      name      avatarUrl      profileUrl    }  }}"}, {"5d12": "Finally, if I want to make that id argument dynamic, I can define a variable and then reuse it inside the query (note that we\u2019re also naming the query here):"}, {"8b4c": "query getMyPost($id: String) {  post(id: $id){    title    body    author{      name      avatarUrl      profileUrl    }  }}"}, {"e0d5": "A good way to put all this in practice is to use GitHub\u2019s GraphQL API Explorer. For example, give the following query a try:"}, {"1e2b": "query {  repository(owner: \"graphql\", name: \"graphql-js\"){    name    description  }}"}, {"2f03": "Notice that as you try typing a new field name below description, the IDE will automatically offer possible field names directly auto-completed from the GraphQL API itself. Neat!"}, {"c9da": "The Anatomy of a GraphQL\u00a0Query"}, {"b425": "You can learn more about GraphQL queries in the excellent Anatomy of a GraphQL Query article."}, {"e313": "Resolvers"}, {"891b": "Even the best personal assistant in the world can\u2019t go and get your dry cleaning unless you give them an address."}, {"c4b1": "Similarly, your GraphQL server won\u2019t know what to do with an incoming query unless you tell it using a resolver."}, {"16c5": "A resolver tells GraphQL how and where to fetch the data corresponding to a given field. For example, here\u2019s what a resolver for the post field above could look like (using Apollo\u2019s GraphQL-Tools schema generator):"}, {"1ff6": "Query: {  post(root, args) {    return Posts.find({ id: args.id });  }}"}, {"3337": "We\u2019re putting the resolver on Query because we want to query for post directly at the root level. But you can also have resolvers for sub-fields, such as a post's author field:"}, {"aebb": "Query: {  post(root, args) {    return Posts.find({ id: args.id });  }},Post: {  author(post) {    return Users.find({ id: post.authorId})  }}"}, {"9e64": "And note that your resolvers are not limited to returning database documents. For example, maybe you want to add a commentsCount to your Post type:"}, {"cf00": "Post: {  author(post) {    return Users.find({ id: post.authorId})  },  commentsCount(post) {    return Comments.find({ postId: post.id}).count()   }}"}, {"3340": "The key concept to understand here is that with GraphQL, your API schema and your database schemas are decoupled. In other words, there might not be any author and commentsCount fields in our database, but we can \u201csimulate\u201d them through the power of resolvers."}, {"21ed": "As you\u2019ve seen you can write any code you want inside a resolver. Which is why you can also make them modify the contents of your database, in which case they\u2019re known as mutation resolvers."}, {"90ee": "Schema"}, {"5986": "All this good stuff is made possible by GraphQL\u2019s typed schema system. My goal today is to give you a quick overview more than an exhaustive introduction, so I won\u2019t go into details here."}, {"e59b": "That being said, I encourage you to check out the GraphQL documentation if you\u2019d like to learn more."}, {"22b7": "Frequently Asked Questions"}, {"15d2": "Let\u2019s take a break to answer a few common questions."}, {"91d9": "You there, in the back. Yes, you. I can see you want to ask something. Go ahead, don\u2019t be shy!"}, {"d91a": "What\u2019s the relation between GraphQL and graph databases?"}, {"873f": "Not much, really, GraphQL doesn\u2019t have anything to do with graph databases like Neo4j. The \u201cgraph\u201d part comes from the idea of crawling across your API graph by using fields and subfields; while \u201cQL\u201d stands for \u201cquery language\u201d."}, {"dc31": "I\u2019m perfectly happy with REST, why should I switch to\u00a0GraphQL?"}, {"234d": "If you haven\u2019t yet bumped into the REST pain points that GraphQL is meant to address, then I would say that\u2019s a good thing!"}, {"c2f1": "Using GraphQL over REST probably won\u2019t affect your app\u2019s overall user experience that much, so switching to it isn\u2019t a matter of life or death by any means. That being said, I\u2019d definitely recommend trying out GraphQL on a small side project if you ever get the chance."}, {"82f9": "Can I use GraphQL without React/Relay/*insert library\u00a0here*?"}, {"1173": "Yes you can! Since GraphQL is just a specification, you can use it with any library on any platform, either with a client (for example, Apollo has GraphQL clients for the web, iOS, Angular, etc.) or by making your own calls to a GraphQL server."}, {"9e94": "GraphQL was made by Facebook, and I don\u2019t trust\u00a0Facebook"}, {"e094": "Again, GraphQL is a specification, meaning you can use GraphQL implementations without running a single line of code written by Facebook."}, {"b3e9": "And while having Facebook\u2019s support is definitely a nice plus for the GraphQL ecosystem, at this point I believe the community is big enough for GraphQL to thrive even if Facebook were to stop using it."}, {"ccb6": "This whole \u201clet the client ask for the data they need\u201d business doesn\u2019t sound very secure to\u00a0me\u2026"}, {"1c3b": "Since you write your own resolvers, it\u2019s up to you to address any security concerns at that level."}, {"243e": "For example, if you let the client specify a limit parameter to control the number of documents it receives, you\u2019ll probably want to cap that number to avoid denial-of-service-style attacks where clients requests millions of documents over and over."}, {"8d9b": "So what do I need to get\u00a0started?"}, {"f97c": "Generally speaking, you\u2019ll need at least two components to run a GraphQL-powered app:"}, {"5691": "Read on to learn more about the various options available."}, {"854a": "Now that you have a fair idea of how GraphQL works, let\u2019s talk about some of the main players in the space."}, {"88db": "GraphQL Servers"}, {"d601": "The first brick you\u2019ll need is a GraphQL server. GraphQL itself is just a specification after all, so this leaves the door open to a few competing implementations."}, {"952b": "GraphQL-JS (Node)"}, {"45f6": "This is the original reference implementation of GraphQL. You can use it together with express-graphql to create your API server."}, {"dda3": "GraphQL-Server (Node)"}, {"74d8": "The Apollo team also has their own all-in-one GraphQL server implementation. It\u2019s not as widespread as the original yet, but is very well documented and supported and quickly gaining ground."}, {"1dae": "Other Platforms"}, {"ed9e": "GraphQL.org has a list of GraphQL implementations for various other platforms (PHP, Ruby, etc.)."}, {"e1fb": "GraphQL Clients"}, {"d6a7": "Although you can technically query your GraphQL API directly without the need for a dedicated client library, it can definitely make your life easier."}, {"c78a": "Relay"}, {"35af": "Relay is Facebook\u2019s own GraphQL toolkit. I haven\u2019t used it myself, but from what I\u2019ve heard it\u2019s mainly tailored to Facebook\u2019s own needs, and might be a bit over-engineered for most usages."}, {"28d6": "Apollo Client"}, {"75fa": "The new entrant in this space is Apollo, and it\u2019s quickly taken over. The typical Apollo client stack is composed of two bricks:"}, {"b290": "Note that by default, Apollo-client stores its data using Redux, which is great since Redux is itself a pretty established state management library with a rich ecosystem."}, {"01c8": "The Apollo Devtools Chrome extension"}, {"eb8a": "Open-Source Apps"}, {"ee8d": "Even though GraphQL is fairly new, there are already some promising open-source apps making use of it."}, {"caa8": "VulcanJS"}, {"151d": "First, a disclaimer: I\u2019m the lead maintainer of VulcanJS. I created VulcanJS to let people take advantage of the power of the React/GraphQL stack without having to write so much boilerplate. You can think of it as \u201cRails for the modern web ecosystem\u201d, in that it lets you build CRUD apps (such as an Instagram clone) in a matter of hours."}, {"6b77": "Gatsby"}, {"a0e1": "Gatsby is a React static site generator, which is now powered by GraphQL as of version 1.0. While that might seem like an odd combination at first, it\u2019s actually quite powerful. During its build process, Gatsby can fetch data from multiple GraphQL APIs, and then use them to create a fully static client-only React app."}, {"f44d": "Other GraphQL\u00a0Tools"}, {"818c": "GraphiQL"}, {"0b9b": "GraphiQL is a very handy in-browser IDE for querying GraphQL endpoints."}, {"57b6": "GraphiQL"}, {"6038": "DataLoader"}, {"c03e": "Due to the nested nature of GraphQL queries, a single query can easily trigger dozens of database calls. To avoid taking a performance hit, you can use a batching and caching library such as DataLoader, developed by Facebook."}, {"2e4b": "Create GraphQL\u00a0Server"}, {"8d03": "Create GraphQL Server is a command line utility that makes it easy to quickly scaffold a GraphQL server powered by a Node server and a Mongo database."}, {"a6d1": "GraphQL-up"}, {"ee14": "Similar to Create GraphQL Server, GraphQL-up lets you quickly bootstrap a new GraphQL back-end powered by GraphCool\u2019s service."}, {"c056": "GraphQL Services"}, {"2bbd": "Finally, there are also a number of \u201cGraphQL-backend-as-a-service\u201d companies that take care of the whole server side of things for you, and might be a nice way to dip your toes in the GraphQL ecosystem."}, {"0936": "Graphcool"}, {"a364": "A flexible backend platform combining GraphQL and AWS Lambda, with a free developer plan."}, {"6afe": "Scaphold"}, {"c719": "Another GraphQL backend as a service, which also has a free plan. It offers a lot of the same features as Graphcool."}, {"fc5b": "There are already quite a few places where you can brush up on GraphQL."}, {"3ad9": "GraphQL.org"}, {"917f": "The official GraphQL site has some great documentation to get you started."}, {"4c9d": "LearnGraphQL"}, {"9a94": "LearnGraphQL is an interactive course put together by the folks at Kadira."}, {"80d3": "LearnApollo"}, {"70ea": "A good follow-up to LearnGraphQL, LearnApollo is a free course made by Graphcool."}, {"339e": "The Apollo\u00a0Blog"}, {"768f": "The Apollo blog has tons of detailed, well-written posts about Apollo and GraphQL in general."}, {"f82d": "GraphQL Weekly"}, {"2736": "A newsletter about all things GraphQL curated by the Graphcool team."}, {"13d2": "Hashbang Weekly"}, {"eab9": "Another great newsletter, which also covers React and Meteor in addition to GraphQL."}, {"9cb8": "Freecom"}, {"80af": "A tutorial series teaching you how to build an Intercom clone using GraphQL."}, {"8a2b": "Awesome GraphQL"}, {"e6c1": "A pretty exhaustive list of GraphQL links and resources."}, {"28c5": "So how do you put your newly acquired GraphQL knowledge in practice? Here are a few recipes you can try:"}, {"b1b8": "Apollo + Graphcool +\u00a0Next.js"}, {"9283": "If you\u2019re already familiar with Next.js and React, this example will let you set up your GraphQL endpoint using Graphcool, and then query it using Apollo."}, {"734c": "VulcanJS"}, {"e9e3": "The Vulcan tutorial will take you through setting up a simple GraphQL data layer, both on the server and client. Since Vulcan is an all-in-one platform, it\u2019s a nice way to get started without any setup. If you need help, don\u2019t hesitate to drop by our Slack channel!"}, {"7fbd": "GraphQL & React\u00a0Tutorial"}, {"894d": "The Chroma blog has a six-part tutorial on building a React/GraphQL app following a component-driven development approach."}, {"fac2": "Conclusion"}, {"483c": "GraphQL might seem complex at first because it\u2019s a technology that reaches across many areas of modern development. But if you take the time to understand the underlying concepts, I think you\u2019ll find out that a lot of it just makes sense."}, {"2a70": "So whether you end up actually using it or not, I believe it\u2019s worth taking the time to familiarize yourself with GraphQL. More and more companies and frameworks are adopting it, and it might very well end up becoming one of the key building blocks of the web over the next few years."}, {"ab0c": "Agree? Disagree? Questions? Just let me know here in the comments. And if you\u2019ve enjoyed this article, please consider \ud83d\udc9aing and sharing it!"}], "content": "So what\u2019s this GraphQL thing I keep hearing\u00a0about? If you\u2019re like me, you probably go through three stages when hearing about a new technology: 1. Dismissal One more JavaScript library?! Just use jQuery already! 2. Interest Hmm, maybe I should check out this new library I keep hearing about\u2026 3. Panic Help! I need to learn this new library right now or I\u2019ll be completely obsolete! The trick to maintaining your sanity in these fast-moving times is to learn new stuff right between stages two and three, once your interest is piqued but while you\u2019re still ahead of the curve. Which is why now is the perfect time to learn what exactly this GraphQL thing you keep hearing about really is. The Basics In a nutshell, GraphQL is a syntax that describes how to ask for data, and is generally used to load data from a server to a client. GraphQL has three main characteristics: So how did GraphQL get started? What does it look like in practice? And how do you start using it? Read on to find out! The Problem GraphQL got its start at big old Facebook, but even much simpler apps can often bump into the limitations of traditional REST APIs. For example, imagine you need to display a list of posts, and under each post a list of likes, including user names and avatars. Easy enough, you tweak your posts API to include a likes array containing user objects: But now, it\u2019s time to work on your mobile app, and it turns out loading all that extra data is slowing things down. So you now need two endpoints, one with the likes and one without them. Now add one more factor to the mix: it turns out that while posts are stored in a MySQL database, likes on the other hand live in a Redis store! What do you do now?! Extrapolate this scenario to however many data sources and API clients Facebook has to manage, and you can imagine why good old REST APIs were starting to show their limits. The Solution The solution Facebook came up with is conceptually very simple: instead of having multiple \u201cdumb\u201d endpoints, have a single \u201csmart\u201d endpoint that can take in complex queries, and then massage the data output into whatever shape the client requires. Practically speaking, the GraphQL layer lives between the client and one or more data sources, receiving client requests and fetching the necessary data according to your instructions. Confused? It\u2019s metaphor time! The old REST model is like ordering pizza, then getting groceries delivered, then calling your dry cleaner to get your clothes. Three shops, three phone calls. GraphQL on the other hand is like having a personal assistant: once you\u2019ve given them the addresses to all three places, you can simply ask for what you want (\u201cget me my dry cleaning, a large pizza, and two dozen eggs\u201d) and wait for them to return. In other words, GraphQL establishes a standard language for talking to this magical personal assistant. In practice, a GraphQL API is organized around three main building blocks: the schema, queries, and resolvers. Queries The request you make to your GraphQL personal assistant is the query, and it looks something like this: query {  stuff} We\u2019re declaring a new query using the query keyword, then asking for a field named stuff. The great thing about GraphQL queries is that they support nested fields, so we can go one level deeper: query {  stuff {    eggs    shirt    pizza  }} As you can see, the client making the query doesn\u2019t need to care which \u201cshop\u201d the data is coming from. Just ask for what you need, and let the GraphQL server take care of the rest. It\u2019s worth noting that query fields can also point to arrays. For example, here\u2019s a common pattern when querying for a list of posts: query {  posts { # this is an array    title    body    author { # we can go deeper!      name      avatarUrl      profileUrl    }  }} Query fields also support arguments. If I want to display a specific post, I can add an id argument to the post field: query {  post(id: \"123foo\"){    title    body    author{      name      avatarUrl      profileUrl    }  }} Finally, if I want to make that id argument dynamic, I can define a variable and then reuse it inside the query (note that we\u2019re also naming the query here): query getMyPost($id: String) {  post(id: $id){    title    body    author{      name      avatarUrl      profileUrl    }  }} A good way to put all this in practice is to use GitHub\u2019s GraphQL API Explorer. For example, give the following query a try: query {  repository(owner: \"graphql\", name: \"graphql-js\"){    name    description  }} Notice that as you try typing a new field name below description, the IDE will automatically offer possible field names directly auto-completed from the GraphQL API itself. Neat! The Anatomy of a GraphQL\u00a0Query You can learn more about GraphQL queries in the excellent Anatomy of a GraphQL Query article. Resolvers Even the best personal assistant in the world can\u2019t go and get your dry cleaning unless you give them an address. Similarly, your GraphQL server won\u2019t know what to do with an incoming query unless you tell it using a resolver. A resolver tells GraphQL how and where to fetch the data corresponding to a given field. For example, here\u2019s what a resolver for the post field above could look like (using Apollo\u2019s GraphQL-Tools schema generator): Query: {  post(root, args) {    return Posts.find({ id: args.id });  }} We\u2019re putting the resolver on Query because we want to query for post directly at the root level. But you can also have resolvers for sub-fields, such as a post's author field: Query: {  post(root, args) {    return Posts.find({ id: args.id });  }},Post: {  author(post) {    return Users.find({ id: post.authorId})  }} And note that your resolvers are not limited to returning database documents. For example, maybe you want to add a commentsCount to your Post type: Post: {  author(post) {    return Users.find({ id: post.authorId})  },  commentsCount(post) {    return Comments.find({ postId: post.id}).count()   }} The key concept to understand here is that with GraphQL, your API schema and your database schemas are decoupled. In other words, there might not be any author and commentsCount fields in our database, but we can \u201csimulate\u201d them through the power of resolvers. As you\u2019ve seen you can write any code you want inside a resolver. Which is why you can also make them modify the contents of your database, in which case they\u2019re known as mutation resolvers. Schema All this good stuff is made possible by GraphQL\u2019s typed schema system. My goal today is to give you a quick overview more than an exhaustive introduction, so I won\u2019t go into details here. That being said, I encourage you to check out the GraphQL documentation if you\u2019d like to learn more. Frequently Asked Questions Let\u2019s take a break to answer a few common questions. You there, in the back. Yes, you. I can see you want to ask something. Go ahead, don\u2019t be shy! What\u2019s the relation between GraphQL and graph databases? Not much, really, GraphQL doesn\u2019t have anything to do with graph databases like Neo4j. The \u201cgraph\u201d part comes from the idea of crawling across your API graph by using fields and subfields; while \u201cQL\u201d stands for \u201cquery language\u201d. I\u2019m perfectly happy with REST, why should I switch to\u00a0GraphQL? If you haven\u2019t yet bumped into the REST pain points that GraphQL is meant to address, then I would say that\u2019s a good thing! Using GraphQL over REST probably won\u2019t affect your app\u2019s overall user experience that much, so switching to it isn\u2019t a matter of life or death by any means. That being said, I\u2019d definitely recommend trying out GraphQL on a small side project if you ever get the chance. Can I use GraphQL without React/Relay/*insert library\u00a0here*? Yes you can! Since GraphQL is just a specification, you can use it with any library on any platform, either with a client (for example, Apollo has GraphQL clients for the web, iOS, Angular, etc.) or by making your own calls to a GraphQL server. GraphQL was made by Facebook, and I don\u2019t trust\u00a0Facebook Again, GraphQL is a specification, meaning you can use GraphQL implementations without running a single line of code written by Facebook. And while having Facebook\u2019s support is definitely a nice plus for the GraphQL ecosystem, at this point I believe the community is big enough for GraphQL to thrive even if Facebook were to stop using it. This whole \u201clet the client ask for the data they need\u201d business doesn\u2019t sound very secure to\u00a0me\u2026 Since you write your own resolvers, it\u2019s up to you to address any security concerns at that level. For example, if you let the client specify a limit parameter to control the number of documents it receives, you\u2019ll probably want to cap that number to avoid denial-of-service-style attacks where clients requests millions of documents over and over. So what do I need to get\u00a0started? Generally speaking, you\u2019ll need at least two components to run a GraphQL-powered app: Read on to learn more about the various options available. Now that you have a fair idea of how GraphQL works, let\u2019s talk about some of the main players in the space. GraphQL Servers The first brick you\u2019ll need is a GraphQL server. GraphQL itself is just a specification after all, so this leaves the door open to a few competing implementations. GraphQL-JS (Node) This is the original reference implementation of GraphQL. You can use it together with express-graphql to create your API server. GraphQL-Server (Node) The Apollo team also has their own all-in-one GraphQL server implementation. It\u2019s not as widespread as the original yet, but is very well documented and supported and quickly gaining ground. Other Platforms GraphQL.org has a list of GraphQL implementations for various other platforms (PHP, Ruby, etc.). GraphQL Clients Although you can technically query your GraphQL API directly without the need for a dedicated client library, it can definitely make your life easier. Relay Relay is Facebook\u2019s own GraphQL toolkit. I haven\u2019t used it myself, but from what I\u2019ve heard it\u2019s mainly tailored to Facebook\u2019s own needs, and might be a bit over-engineered for most usages. Apollo Client The new entrant in this space is Apollo, and it\u2019s quickly taken over. The typical Apollo client stack is composed of two bricks: Note that by default, Apollo-client stores its data using Redux, which is great since Redux is itself a pretty established state management library with a rich ecosystem. The Apollo Devtools Chrome extension Open-Source Apps Even though GraphQL is fairly new, there are already some promising open-source apps making use of it. VulcanJS First, a disclaimer: I\u2019m the lead maintainer of VulcanJS. I created VulcanJS to let people take advantage of the power of the React/GraphQL stack without having to write so much boilerplate. You can think of it as \u201cRails for the modern web ecosystem\u201d, in that it lets you build CRUD apps (such as an Instagram clone) in a matter of hours. Gatsby Gatsby is a React static site generator, which is now powered by GraphQL as of version 1.0. While that might seem like an odd combination at first, it\u2019s actually quite powerful. During its build process, Gatsby can fetch data from multiple GraphQL APIs, and then use them to create a fully static client-only React app. Other GraphQL\u00a0Tools GraphiQL GraphiQL is a very handy in-browser IDE for querying GraphQL endpoints. GraphiQL DataLoader Due to the nested nature of GraphQL queries, a single query can easily trigger dozens of database calls. To avoid taking a performance hit, you can use a batching and caching library such as DataLoader, developed by Facebook. Create GraphQL\u00a0Server Create GraphQL Server is a command line utility that makes it easy to quickly scaffold a GraphQL server powered by a Node server and a Mongo database. GraphQL-up Similar to Create GraphQL Server, GraphQL-up lets you quickly bootstrap a new GraphQL back-end powered by GraphCool\u2019s service. GraphQL Services Finally, there are also a number of \u201cGraphQL-backend-as-a-service\u201d companies that take care of the whole server side of things for you, and might be a nice way to dip your toes in the GraphQL ecosystem. Graphcool A flexible backend platform combining GraphQL and AWS Lambda, with a free developer plan. Scaphold Another GraphQL backend as a service, which also has a free plan. It offers a lot of the same features as Graphcool. There are already quite a few places where you can brush up on GraphQL. GraphQL.org The official GraphQL site has some great documentation to get you started. LearnGraphQL LearnGraphQL is an interactive course put together by the folks at Kadira. LearnApollo A good follow-up to LearnGraphQL, LearnApollo is a free course made by Graphcool. The Apollo\u00a0Blog The Apollo blog has tons of detailed, well-written posts about Apollo and GraphQL in general. GraphQL Weekly A newsletter about all things GraphQL curated by the Graphcool team. Hashbang Weekly Another great newsletter, which also covers React and Meteor in addition to GraphQL. Freecom A tutorial series teaching you how to build an Intercom clone using GraphQL. Awesome GraphQL A pretty exhaustive list of GraphQL links and resources. So how do you put your newly acquired GraphQL knowledge in practice? Here are a few recipes you can try: Apollo + Graphcool +\u00a0Next.js If you\u2019re already familiar with Next.js and React, this example will let you set up your GraphQL endpoint using Graphcool, and then query it using Apollo. VulcanJS The Vulcan tutorial will take you through setting up a simple GraphQL data layer, both on the server and client. Since Vulcan is an all-in-one platform, it\u2019s a nice way to get started without any setup. If you need help, don\u2019t hesitate to drop by our Slack channel! GraphQL & React\u00a0Tutorial The Chroma blog has a six-part tutorial on building a React/GraphQL app following a component-driven development approach. Conclusion GraphQL might seem complex at first because it\u2019s a technology that reaches across many areas of modern development. But if you take the time to understand the underlying concepts, I think you\u2019ll find out that a lot of it just makes sense. So whether you end up actually using it or not, I believe it\u2019s worth taking the time to familiarize yourself with GraphQL. More and more companies and frameworks are adopting it, and it might very well end up becoming one of the key building blocks of the web over the next few years. Agree? Disagree? Questions? Just let me know here in the comments. And if you\u2019ve enjoyed this article, please consider \ud83d\udc9aing and sharing it! ", "name": "839", "child": "839_1\t839_2\t839_3\t839_4\t839_5\t839_6\t839_7\t839_8\t839_9\t839_10\t839_11\t839_12\t839_13\t839_14\t839_15\t839_16\t839_17\t839_18\t839_19\t839_20\t839_21\t839_22\t839_23\t839_24", "timestamp": "Apr 11"}