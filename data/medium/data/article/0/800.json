{"parent": "", "title": "Why I Love\u00a0Golang", "author": "Sergio Nadir", "sentences": [{"182e": "Why I Love\u00a0Golang"}, {"6110": "I love the Go programming language, or as some refer to it, Golang. It\u2019s simple and it\u2019s great."}, {"0047": "I write this on a tangent. Didn\u2019t expect Golang to be so good."}, {"0596": "I first picked up go around January 2016, it had a relative small but enthusiastic community here in Israel."}, {"b662": "I didn\u2019t think much of it at the time, I was honing my programming skills and Golang was just a tool I\u2019ve used to accomplish a task."}, {"b162": "Even one year ago, using go was brilliant. The process was straightforward once I\u2019ve got the general hang of the language."}, {"9d62": "I wrote a crucial piece of code for Visualead, the company I work for, and it didn\u2019t let us down, still running in production a year later with zero maintenance since then."}, {"3707": "Recently I found myself again using Golang again, and I felt compelled to write about the reasons I fell in love with Golang."}, {"aac3": "The GOPATH environment"}, {"ed89": "This is one of the first things you\u2019ll have to handle once you begin writing in Go."}, {"ce5a": "Setup your GOPATH directory anywhere on your computer, complete with bin, src, and pkg directories and you are ready to begin writing."}, {"6209": "// How the directory structure looks like:go- bin- pkg- src"}, {"2f4e": "Under my home directory I create a new directory for every programming language I write in. My user home directory is filled with folders like these:"}, {"52c8": "chefcppelixirelmgojavascriptmeteorocamlphppythonscala"}, {"28fb": "None of these languages enforce this structure besides Go. Go forces you to define a root directory for all of your Golang goodies, and it does it for a good reasons which are coming right up."}, {"248d": "The Golang Application"}, {"c610": "Want to create a new Golang applications? Simple."}, {"b944": "Go to your $GOPATH/src directory, create a new folder, create a new file.go\u00a0, call the package main\u00a0, add a func main() {} function and that\u2019s it. all of the Go goodies are available to you since that moment forward."}, {"cecc": "More on Go goodies coming up! but first a few words about the Golang modules."}, {"0b51": "The Golang\u00a0Modules"}, {"8ceb": "My favorite programming paradigm done right. I see the module system as a sort of alternative to the Object Oriented classes system."}, {"29cb": "Golang calls it\u2019s modules packages. So from now on everytime we say a module we mean a package and vise-versa."}, {"69c7": "Module == Package == Module"}, {"14f9": "In Golang every directory you create becomes a package. A package can become an application if it\u2019s name is main.This is helps with a natural separation of code into manageable logical chunks."}, {"a881": "You always want your business logic to be created from reusable components, or packages in case of Golang."}, {"c903": "In my current app I have to manipulate some lines in some files, and upload them to AWS S3 once i\u2019m done."}, {"be67": "My app structure looks like this:"}, {"2dae": "src- my_app- - main.go- - main_test.go- - uploader- - - uploader.go- - - uploader_test.go- - replace_file_lines- - - replace.go- - - replace_test.go- - - strings_util.go- - - strings_util_test.go"}, {"1a85": "The _test.go files are of course the way to do unit test files for Golang, which has a testing framework built in it\u2019s core."}, {"8563": "Also to those who are coming from an object oriented language, it helps to think that every directory here is a complete static class, and every function or variable inside the\u00a0.go files becomes it either a property or method."}, {"efcb": "Here\u2019s a possible example of how replace.go can look like:"}, {"c39e": "If a directory shares more than one\u00a0.go file, all the methods and variables are shared between the entire package, even the private ones. It helps for separating a package into even smaller chunks and avoiding large single files."}, {"71e7": "Without going into Object Oriented vs Functional/Procedural, it\u2019s just important to know that the Go creators decided to not include classic classes it the language. Instead opted to use structs/interfaces, and packages of course."}, {"e973": "The Golang\u00a0gofmt"}, {"7b66": "Golang has a convention of how everything is supposed to look, the exact spacing which is needed in each case and each line."}, {"bab5": "This allows developers to focus on writing code instead waging wars about curly braces locations."}, {"e365": "The old {} vs { \\n } war:"}, {"ee77": "Or perhaps I am only happy because my side won in\u00a0Go?"}, {"8bc1": "Read more about it here: https://golang.org/cmd/gofmt/"}, {"89ff": "The Golang\u00a0Import"}, {"5bd1": "imports are always relative to GOPATH/src\u00a0. Always. I cannot overstate how much this decisions saves me in frustration."}, {"0a1a": "Warning: the next line is confusing by intention."}, {"73ff": "When working with other languages you either can use relative/absolute imports, or somehow set a weird import that will allow you to import a file from whoknowswhere location ( I am looking at you Python )."}, {"7ba9": "Go solves it in a unique way. All imports, no matter in which file, will always be relative to GOPATH/src"}, {"934d": "So in case of my_app, it\u2019s main imports will look like this:"}, {"0110": "my_app is under src, so we need to mention it first, then we import the packages that exist under my_app\u00a0, like uploader and replace_file_lines\u00a0. Notice we are not importing single files, but instead whole packages. Works like a charm and causes ZERO confusion."}, {"1c27": "Furthermore, Golang won\u2019t compile unless you actually use the packages you import, this tiny feature helps you to know that every import is actually used."}, {"4a16": "Expecting your programmers to write a clean code without unused imports? why won\u2019t you let your local Gopher take care of that?"}, {"2783": "The Golang Get\u00a0System"}, {"0a25": "The import sections leads us to the next great feature of Golang, the go get feature. While others are impressed with JavaScripts NPM package manager, Go just uses any git repository as it\u2019s package manager."}, {"a6c9": "How does it work?"}, {"587a": "I\u2019ve wrote before that I needed to upload to S3 right? well then that means I need to AWS SDK to accomplish that."}, {"0d6e": "To make this work, I just open my terminal and write:"}, {"3fef": "go get github.com/aws/aws-sdk-go"}, {"f046": "What\u2019s going on here? Nothing special, Golang just downloads the repo from https://github.com/aws/aws-sdk-go into your GOPATH/src directory."}, {"f27a": "Then all you have to do to use the aws-sdk is just import it:"}, {"1064": "Remember that all imports are relative to the GOPATH/src\u00a0? From that you can understand that the s3 package for example resides now under GOPATH/src/github.com/aws/aws-sdk-go/services/s3\u00a0."}, {"b1fb": "Simple. Elegant. Another star for the Gopher."}, {"a5a0": "The Golang Build and Package\u00a0Systems"}, {"4ae4": "We\u2019ve been focusing so far on GOPATH/src but there are still other directories we need to address, GOPATH/pkg and GOPATH/bin\u00a0."}, {"57e3": "Golang is a compiled language, it means that the code has to be compiled in order to run. Golang is compiled fast. How does it work?"}, {"edcd": "Everytime your compile your code to run it, Golang creates a\u00a0.a file in the same path as your package, only under the GOPATH/pkg directory. It means that if you compiled the aws-sdk for example. It\u2019ll be compiled once, and shared between all of your other code."}, {"23db": "Of course this is not the only reason Golang compiles fast, but it\u2019s just an intro that helps you to understand the role of GOPATH/pkg"}, {"ff4a": "Now, what about GOPATH/bin\u00a0? When you run the go install command, go creates a binary file, and places it under GOPATH/bin\u00a0, the file gets the name of your main package\u2019s directory my-app in our case."}, {"ea72": "Why is it so great? Well you can add GOPATH/bin into your global PATH variable, and all binaries your build are available in your command line, without you doing any extra work! ( Isn\u2019t it great\u00a0:D\u00a0? )"}, {"7f63": "The Golang Cross Platform\u00a0Builds"}, {"3907": "Deploying to other distributions instead of the one you are writing your code on? Well don\u2019t worry, you don\u2019t need to have a windows machine to build your code for windows. Golang got you covered."}, {"2915": "Just run:"}, {"1d3b": "GOOS=windows GOARCH=amd64 go install"}, {"238f": "And our code will output a binary ready to deploy on a windows machine. The\u00a0.exe file will appear at GOPATH/bin/windows_amd64/my_app.exe\u00a0. Like a walk in the park."}, {"12c0": "The Golang\u00a0Language"}, {"0b1b": "Golang is aimed to be a simple language."}, {"ac96": "I love the following post asking why Go wasn\u2019t designed to be a functional language: https://www.quora.com/Why-wasnt-Go-written-as-a-functional-language"}, {"b0a0": "\u201cProgrammers working at Google are early in their careers and are most familiar with procedural languages, particularly from the C family. The need to get programmers productive quickly in a new language means that the language cannot be too radical\u201d"}, {"72bb": "And simple it is."}, {"af11": "Here\u2019s a list of some features Golang doesn\u2019t support:"}, {"24a6": "While sometimes I find myself missing language features when writing in Go, I can always do everything that I want. Just sometimes it requires more writing and sometimes thinking. The bottom line is, it leads to code which is easier to reason with because it\u2019s less abstract."}, {"cd61": "It sometimes amazes me how fast I can achieve a goal when writing in Go, without having years of experience, just because the language is so accommodating and clear."}, {"d29b": "The Golang Concurrency"}, {"17c6": "I have left the concurrency talk by intention to be last. Why? because I don\u2019t think it\u2019s so important."}, {"c47f": "It\u2019s an amazing feature of the language. But sometimes it\u2019s presented as the essence of Go, which I believe it is not."}, {"1a45": "Therefore let me try to sum it up in one paragraph."}, {"a096": "Yeah, Golang has great concurrency. You don\u2019t deal with threads but rather create cheap goroutines which are simple to make and manage. Goroutines allow you to distribute the load across all of your CPUs without worrying on how to manage it all."}, {"7acf": "Still interested in understanding goroutines? Read about them here: https://tour.golang.org/concurrency/1"}, {"9afa": "The Golang\u00a0Gopher"}, {"3d77": "Come on, he\u2019s just so CUTE!"}, {"ba50": "Did I mention I am a Functional Programming enthusiast? Then why I am so attracted to Golang? it doesn\u2019t even have a concept for monads. Who knows\u2026 The universe works in mysterious ways."}], "content": "Why I Love\u00a0Golang I love the Go programming language, or as some refer to it, Golang. It\u2019s simple and it\u2019s great. I write this on a tangent. Didn\u2019t expect Golang to be so good. I first picked up go around January 2016, it had a relative small but enthusiastic community here in Israel. I didn\u2019t think much of it at the time, I was honing my programming skills and Golang was just a tool I\u2019ve used to accomplish a task. Even one year ago, using go was brilliant. The process was straightforward once I\u2019ve got the general hang of the language. I wrote a crucial piece of code for Visualead, the company I work for, and it didn\u2019t let us down, still running in production a year later with zero maintenance since then. Recently I found myself again using Golang again, and I felt compelled to write about the reasons I fell in love with Golang. The GOPATH environment This is one of the first things you\u2019ll have to handle once you begin writing in Go. Setup your GOPATH directory anywhere on your computer, complete with bin, src, and pkg directories and you are ready to begin writing. // How the directory structure looks like:go- bin- pkg- src Under my home directory I create a new directory for every programming language I write in. My user home directory is filled with folders like these: chefcppelixirelmgojavascriptmeteorocamlphppythonscala None of these languages enforce this structure besides Go. Go forces you to define a root directory for all of your Golang goodies, and it does it for a good reasons which are coming right up. The Golang Application Want to create a new Golang applications? Simple. Go to your $GOPATH/src directory, create a new folder, create a new file.go\u00a0, call the package main\u00a0, add a func main() {} function and that\u2019s it. all of the Go goodies are available to you since that moment forward. More on Go goodies coming up! but first a few words about the Golang modules. The Golang\u00a0Modules My favorite programming paradigm done right. I see the module system as a sort of alternative to the Object Oriented classes system. Golang calls it\u2019s modules packages. So from now on everytime we say a module we mean a package and vise-versa. Module == Package == Module In Golang every directory you create becomes a package. A package can become an application if it\u2019s name is main.This is helps with a natural separation of code into manageable logical chunks. You always want your business logic to be created from reusable components, or packages in case of Golang. In my current app I have to manipulate some lines in some files, and upload them to AWS S3 once i\u2019m done. My app structure looks like this: src- my_app- - main.go- - main_test.go- - uploader- - - uploader.go- - - uploader_test.go- - replace_file_lines- - - replace.go- - - replace_test.go- - - strings_util.go- - - strings_util_test.go The _test.go files are of course the way to do unit test files for Golang, which has a testing framework built in it\u2019s core. Also to those who are coming from an object oriented language, it helps to think that every directory here is a complete static class, and every function or variable inside the\u00a0.go files becomes it either a property or method. Here\u2019s a possible example of how replace.go can look like: If a directory shares more than one\u00a0.go file, all the methods and variables are shared between the entire package, even the private ones. It helps for separating a package into even smaller chunks and avoiding large single files. Without going into Object Oriented vs Functional/Procedural, it\u2019s just important to know that the Go creators decided to not include classic classes it the language. Instead opted to use structs/interfaces, and packages of course. The Golang\u00a0gofmt Golang has a convention of how everything is supposed to look, the exact spacing which is needed in each case and each line. This allows developers to focus on writing code instead waging wars about curly braces locations. The old {} vs { \\n } war: Or perhaps I am only happy because my side won in\u00a0Go? Read more about it here: https://golang.org/cmd/gofmt/ The Golang\u00a0Import imports are always relative to GOPATH/src\u00a0. Always. I cannot overstate how much this decisions saves me in frustration. Warning: the next line is confusing by intention. When working with other languages you either can use relative/absolute imports, or somehow set a weird import that will allow you to import a file from whoknowswhere location ( I am looking at you Python ). Go solves it in a unique way. All imports, no matter in which file, will always be relative to GOPATH/src So in case of my_app, it\u2019s main imports will look like this: my_app is under src, so we need to mention it first, then we import the packages that exist under my_app\u00a0, like uploader and replace_file_lines\u00a0. Notice we are not importing single files, but instead whole packages. Works like a charm and causes ZERO confusion. Furthermore, Golang won\u2019t compile unless you actually use the packages you import, this tiny feature helps you to know that every import is actually used. Expecting your programmers to write a clean code without unused imports? why won\u2019t you let your local Gopher take care of that? The Golang Get\u00a0System The import sections leads us to the next great feature of Golang, the go get feature. While others are impressed with JavaScripts NPM package manager, Go just uses any git repository as it\u2019s package manager. How does it work? I\u2019ve wrote before that I needed to upload to S3 right? well then that means I need to AWS SDK to accomplish that. To make this work, I just open my terminal and write: go get github.com/aws/aws-sdk-go What\u2019s going on here? Nothing special, Golang just downloads the repo from https://github.com/aws/aws-sdk-go into your GOPATH/src directory. Then all you have to do to use the aws-sdk is just import it: Remember that all imports are relative to the GOPATH/src\u00a0? From that you can understand that the s3 package for example resides now under GOPATH/src/github.com/aws/aws-sdk-go/services/s3\u00a0. Simple. Elegant. Another star for the Gopher. The Golang Build and Package\u00a0Systems We\u2019ve been focusing so far on GOPATH/src but there are still other directories we need to address, GOPATH/pkg and GOPATH/bin\u00a0. Golang is a compiled language, it means that the code has to be compiled in order to run. Golang is compiled fast. How does it work? Everytime your compile your code to run it, Golang creates a\u00a0.a file in the same path as your package, only under the GOPATH/pkg directory. It means that if you compiled the aws-sdk for example. It\u2019ll be compiled once, and shared between all of your other code. Of course this is not the only reason Golang compiles fast, but it\u2019s just an intro that helps you to understand the role of GOPATH/pkg Now, what about GOPATH/bin\u00a0? When you run the go install command, go creates a binary file, and places it under GOPATH/bin\u00a0, the file gets the name of your main package\u2019s directory my-app in our case. Why is it so great? Well you can add GOPATH/bin into your global PATH variable, and all binaries your build are available in your command line, without you doing any extra work! ( Isn\u2019t it great\u00a0:D\u00a0? ) The Golang Cross Platform\u00a0Builds Deploying to other distributions instead of the one you are writing your code on? Well don\u2019t worry, you don\u2019t need to have a windows machine to build your code for windows. Golang got you covered. Just run: GOOS=windows GOARCH=amd64 go install And our code will output a binary ready to deploy on a windows machine. The\u00a0.exe file will appear at GOPATH/bin/windows_amd64/my_app.exe\u00a0. Like a walk in the park. The Golang\u00a0Language Golang is aimed to be a simple language. I love the following post asking why Go wasn\u2019t designed to be a functional language: https://www.quora.com/Why-wasnt-Go-written-as-a-functional-language \u201cProgrammers working at Google are early in their careers and are most familiar with procedural languages, particularly from the C family. The need to get programmers productive quickly in a new language means that the language cannot be too radical\u201d And simple it is. Here\u2019s a list of some features Golang doesn\u2019t support: While sometimes I find myself missing language features when writing in Go, I can always do everything that I want. Just sometimes it requires more writing and sometimes thinking. The bottom line is, it leads to code which is easier to reason with because it\u2019s less abstract. It sometimes amazes me how fast I can achieve a goal when writing in Go, without having years of experience, just because the language is so accommodating and clear. The Golang Concurrency I have left the concurrency talk by intention to be last. Why? because I don\u2019t think it\u2019s so important. It\u2019s an amazing feature of the language. But sometimes it\u2019s presented as the essence of Go, which I believe it is not. Therefore let me try to sum it up in one paragraph. Yeah, Golang has great concurrency. You don\u2019t deal with threads but rather create cheap goroutines which are simple to make and manage. Goroutines allow you to distribute the load across all of your CPUs without worrying on how to manage it all. Still interested in understanding goroutines? Read about them here: https://tour.golang.org/concurrency/1 The Golang\u00a0Gopher Come on, he\u2019s just so CUTE! Did I mention I am a Functional Programming enthusiast? Then why I am so attracted to Golang? it doesn\u2019t even have a concept for monads. Who knows\u2026 The universe works in mysterious ways. ", "name": "800", "child": "800_1\t800_2\t800_3\t800_4\t800_5\t800_6\t800_7\t800_8800_1\t800_2\t800_3\t800_4\t800_5\t800_6\t800_7\t800_8", "timestamp": "Apr 11"}