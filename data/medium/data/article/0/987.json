{"parent": "", "title": "Lightning Components & AuraEnabled method parameters: What\u2019s working and what\u2019s\u00a0not", "author": "Fabien Taillon", "sentences": [{"245d": "Lightning Components & AuraEnabled method parameters: What\u2019s working and what\u2019s\u00a0not"}, {"6315": "Passing values from client-side to server-side is an important part of Lightning Component Development, and is pretty easy once you understood the way to write it. In\u00a0theory."}, {"ce1a": "Passing a value to a server-side controller"}, {"8834": "Let\u2019s take a very simple example of a server-side call in a Lightning Component. There is 3 parts in this call:"}, {"596f": "A very basic component that would send a String to the server would look like this:"}, {"9d4e": "Component"}, {"7be4": "<aura:component controller=\"myApexController\">  <aura:handler name=\"init\" value=\"{!this}\" action=\"{!c.callServer}\"/>  <aura:attribute name=\u201dmyAttribute\u201d type=\u201dString\u201d default=\u201dHello World\u201d/></aura:component>"}, {"cadc": "JavaScript Client-side Controller"}, {"ecc1": "callServer : function(component, event, helper) {  var myAttribute = component.get(\"v.myAttribute\");"}, {"5569": "  var action = component.get(\"c.setAttribute\");  action.setParams({ \"myString\" : myAttribute });  action.setCallback(this, function(response) {     var state = response.getState();    if (state === \u201cSUCCESS\u201d) {      // Do stuff    }     else {      console.log(state);    }  });"}, {"d9ae": "  $A.enqueueAction(action);}"}, {"a27b": "Apex Server-side Controller"}, {"04b7": "@AuraEnabledpublic static void setAttribute(String myString) {  System.debug(myString);}"}, {"f07c": "As you would expect, the client-side attribute and the apex method parameter have the same type. On Lightning side, available aura:attribute types are listed here. On server-side, well it\u2019s Apex, so you can make use of the types you\u2019re used to."}, {"4a8b": "However, using the same type client-side and server-side doesn\u2019t always work the way you would expect. If using a String, Boolean or DateTime (non-exhaustive list) is working fine, some other types have some glitches that may drive you crazy the first time you encounter them. Let\u2019s have a look."}, {"ebc5": "Integer"}, {"f9e3": "Integer was the first type I encountered issues with. This is such a basic type that it took me some time to understand that it wasn\u2019t my code that had an issue, but the framework itself. Let\u2019s take the following example:"}, {"e766": "Component"}, {"dc75": "<aura:attribute name=\u201dmyInteger\u201d type=\u201dInteger\u201d default=\u201d1\u201d/>"}, {"c4d8": "Note: I won\u2019t write again the JavaScript Client-side Controller, as it\u2019s only used to pass the value from the Component markup to the Apex server method, and would be exactly the same for all our examples."}, {"c834": "Server-side Controller"}, {"c098": "@AuraEnabledpublic static void setInteger(Integer myInteger) {  System.debug(myInteger);}"}, {"1eb9": "You can run this code, have a look to the logs, and feel happy: your integer value will be displayed. Until you use it. Just add the following line to your Apex method:"}, {"a36a": "myInteger++;"}, {"90bd": "If you run your code again, you\u2019ll see that it\u2019s crashing with an error server-side: FATAL_ERROR Internal Salesforce.com Error. This is because the myInteger parameter isn\u2019t casted correctly to an Integer by the framework. So you\u2019ll need to simply cast it again manually in your Apex code, and then everything will be fine:"}, {"ad50": "myInteger = Integer.valueOf(myInteger);myInteger++;"}, {"85eb": "This is a very easy workaround that can save you time if you encounter a strange behavior while using an Integer attribute. This is not only about doing maths on your attribute, but any other operation that needs an Integer and not a String. Another good example is using it inside an soql query, for a Limit for instance."}, {"e3b2": "sObjects"}, {"c19f": "These are really important in Lightning, as you\u2019ll have to manipulate Salesforce objects all the time. Don\u2019t worry, they are working fine, and you can safely pass one sObject attribute from client-side to server-side."}, {"62d0": "The only thing I\u2019ve noticed, is that relationships won\u2019t be available in the Apex method attribute: For instance, if you have a Account attribute, with a list of Contacts populated in the sObject, once in the Apex method"}, {"78c6": "On a side note, remember that with Lightning Data Service you may not even have to query the server anymore to get the record you need."}, {"21dc": "Date"}, {"668f": "I was not able to use Date in an AuraEnabled method, the passed attribute always ends up being null:"}, {"8120": "Component"}, {"a029": "<aura:attribute name=\u201dmyDate\u201d type=\u201dDate\u201d default=\u201d1981\u201308\u201326\"/>"}, {"d740": "Server-side Controller"}, {"2813": "@AuraEnabledpublic static void setDate(Date myDate) {  System.debug(myDate); // --> null}"}, {"66f4": "However, the workaround is pretty easy to implement, just pass the date as a string, and then cast it to a Date:"}, {"030e": "@AuraEnabledpublic static void setDate(String myDate) {  Date myNewDate = Date.valueOf(myDate);}"}, {"099b": "Again, this is easy to do, but you can lose some time just asking yourself what is wrong in your code and why the date is null in your Apex controller."}, {"a0b3": "Apex Class"}, {"07b5": "You can use an Apex class as an aura:attribute type. This can be convenient if you want to pass your data in a specific format while having a more structured way than just writing a json object manually. For instance, you\u2019ll need it if you want to use SelectOption at some point."}, {"73a2": "Unfortunately, I was not able to make it work. Every time I tried I received the following error: An internal server error has occurred."}, {"530b": "Apex NewWrapperClass"}, {"79c9": "public class NewWrapperClass {  @AuraEnabled  public String label {get; set;}}"}, {"9456": "Component"}, {"70bf": "<aura:attribute name=\u201dmyApexClass\u201d type=\u201dNewWrapperClass\u201d />"}, {"1c2f": "Client-side Controller"}, {"9b8c": "callServer : function(component, event, helper) {  var myClass = component.get(\"v.myApexClass\");"}, {"4b38": "  var action = component.get(\"c.setApexClassType\");  action.setParams({ \"myApexClass\" : myClass });  action.setCallback(this, function(response) {    // Do stuff  });"}, {"4762": "  $A.enqueueAction(action);}"}, {"6667": "Server-side Controller"}, {"093b": "@AuraEnabledpublic Static void setApexClassType(NewWrapperClass myApexClass) {  System.debug(myApexClass);}"}, {"4c3b": "The best way I found to pass an Apex class to your AuraEnabled method is stringify it on client-side, and then deserialize it in Apex. The following code will work fine:"}, {"a6b3": "Client-side Controller"}, {"3940": "callServer : function(component, event, helper) {  var myClass = component.get(\"v.myApexClass\");"}, {"d739": "  var action = component.get(\"c.setApexClassType\");  action.setParams({ \"myApexClass\" : JSON.stringify(myClass) });  action.setCallback(this, function(response) {     var state = response.getState();    if (state === \u201cSUCCESS\u201d) {      // Do stuff    }     else {      console.log(state);    }  });"}, {"3118": "$A.enqueueAction(action);}action.setParams({ wrap : "}, {"6cc7": "Server-side Controller"}, {"cc44": "@AuraEnabledpublic static void setApexClassType(String myApexClass) {  NewWrapperClass nwc = (NewWrapperClass)JSON.deserialize(myApexClass, NewWrapperClass.class);}"}, {"8e3a": "Set"}, {"bf30": "You won\u2019t be able to use a Set, but at least you won\u2019t have any surprise with this one. Try to save an AuraEnabled method with a parameter of type Set<String>, and you\u2019ll see the following error message, preventing you to save: Parameter type does not support AuraEnabled: Set<String>."}, {"9075": "List and Map are working perfectly though."}, {"cd27": "Bonus tip:\u00a0base64"}, {"b280": "This is something that is not specific to Lightning, but that may be useful if you want to pass a file to your Apex method. Don\u2019t forget to encode/decode the file:"}, {"15d4": "Client-side Controller"}, {"4ad2": "var action = component.get(\"c.setFile\");action.setParams({ myBase64File : encodeURIComponent(base64File) });action.setCallback(this, function(response) {   var state = response.getState();  if (state === \u201cSUCCESS\u201d) {    // Do stuff  }   else {   console.log(state);  }});$A.enqueueAction(action);"}, {"fef9": "Server-side Controller"}, {"8060": "@AuraEnabledpublic static void setFile(String myBase64File) {  String myFile = EncodingUtil.urlDecode(myBase64File, \u2018UTF-8\u2019);}"}, {"b811": "Wrapping up"}, {"57fa": "Lightning is still a young framework, and I\u2019m sure most of the strange behaviors described here will be fixed in the future. However in the meantime, I hope this will help some of you save the time I\u2019ve lost when I encountered them."}, {"2446": "Also, if you\u2019ve seen some other weird things I would have missed with other types, please feel free to add them in the comments."}], "content": "Lightning Components & AuraEnabled method parameters: What\u2019s working and what\u2019s\u00a0not Passing values from client-side to server-side is an important part of Lightning Component Development, and is pretty easy once you understood the way to write it. In\u00a0theory. Passing a value to a server-side controller Let\u2019s take a very simple example of a server-side call in a Lightning Component. There is 3 parts in this call: A very basic component that would send a String to the server would look like this: Component <aura:component controller=\"myApexController\">  <aura:handler name=\"init\" value=\"{!this}\" action=\"{!c.callServer}\"/>  <aura:attribute name=\u201dmyAttribute\u201d type=\u201dString\u201d default=\u201dHello World\u201d/></aura:component> JavaScript Client-side Controller callServer : function(component, event, helper) {  var myAttribute = component.get(\"v.myAttribute\");   var action = component.get(\"c.setAttribute\");  action.setParams({ \"myString\" : myAttribute });  action.setCallback(this, function(response) {     var state = response.getState();    if (state === \u201cSUCCESS\u201d) {      // Do stuff    }     else {      console.log(state);    }  });   $A.enqueueAction(action);} Apex Server-side Controller @AuraEnabledpublic static void setAttribute(String myString) {  System.debug(myString);} As you would expect, the client-side attribute and the apex method parameter have the same type. On Lightning side, available aura:attribute types are listed here. On server-side, well it\u2019s Apex, so you can make use of the types you\u2019re used to. However, using the same type client-side and server-side doesn\u2019t always work the way you would expect. If using a String, Boolean or DateTime (non-exhaustive list) is working fine, some other types have some glitches that may drive you crazy the first time you encounter them. Let\u2019s have a look. Integer Integer was the first type I encountered issues with. This is such a basic type that it took me some time to understand that it wasn\u2019t my code that had an issue, but the framework itself. Let\u2019s take the following example: Component <aura:attribute name=\u201dmyInteger\u201d type=\u201dInteger\u201d default=\u201d1\u201d/> Note: I won\u2019t write again the JavaScript Client-side Controller, as it\u2019s only used to pass the value from the Component markup to the Apex server method, and would be exactly the same for all our examples. Server-side Controller @AuraEnabledpublic static void setInteger(Integer myInteger) {  System.debug(myInteger);} You can run this code, have a look to the logs, and feel happy: your integer value will be displayed. Until you use it. Just add the following line to your Apex method: myInteger++; If you run your code again, you\u2019ll see that it\u2019s crashing with an error server-side: FATAL_ERROR Internal Salesforce.com Error. This is because the myInteger parameter isn\u2019t casted correctly to an Integer by the framework. So you\u2019ll need to simply cast it again manually in your Apex code, and then everything will be fine: myInteger = Integer.valueOf(myInteger);myInteger++; This is a very easy workaround that can save you time if you encounter a strange behavior while using an Integer attribute. This is not only about doing maths on your attribute, but any other operation that needs an Integer and not a String. Another good example is using it inside an soql query, for a Limit for instance. sObjects These are really important in Lightning, as you\u2019ll have to manipulate Salesforce objects all the time. Don\u2019t worry, they are working fine, and you can safely pass one sObject attribute from client-side to server-side. The only thing I\u2019ve noticed, is that relationships won\u2019t be available in the Apex method attribute: For instance, if you have a Account attribute, with a list of Contacts populated in the sObject, once in the Apex method On a side note, remember that with Lightning Data Service you may not even have to query the server anymore to get the record you need. Date I was not able to use Date in an AuraEnabled method, the passed attribute always ends up being null: Component <aura:attribute name=\u201dmyDate\u201d type=\u201dDate\u201d default=\u201d1981\u201308\u201326\"/> Server-side Controller @AuraEnabledpublic static void setDate(Date myDate) {  System.debug(myDate); // --> null} However, the workaround is pretty easy to implement, just pass the date as a string, and then cast it to a Date: @AuraEnabledpublic static void setDate(String myDate) {  Date myNewDate = Date.valueOf(myDate);} Again, this is easy to do, but you can lose some time just asking yourself what is wrong in your code and why the date is null in your Apex controller. Apex Class You can use an Apex class as an aura:attribute type. This can be convenient if you want to pass your data in a specific format while having a more structured way than just writing a json object manually. For instance, you\u2019ll need it if you want to use SelectOption at some point. Unfortunately, I was not able to make it work. Every time I tried I received the following error: An internal server error has occurred. Apex NewWrapperClass public class NewWrapperClass {  @AuraEnabled  public String label {get; set;}} Component <aura:attribute name=\u201dmyApexClass\u201d type=\u201dNewWrapperClass\u201d /> Client-side Controller callServer : function(component, event, helper) {  var myClass = component.get(\"v.myApexClass\");   var action = component.get(\"c.setApexClassType\");  action.setParams({ \"myApexClass\" : myClass });  action.setCallback(this, function(response) {    // Do stuff  });   $A.enqueueAction(action);} Server-side Controller @AuraEnabledpublic Static void setApexClassType(NewWrapperClass myApexClass) {  System.debug(myApexClass);} The best way I found to pass an Apex class to your AuraEnabled method is stringify it on client-side, and then deserialize it in Apex. The following code will work fine: Client-side Controller callServer : function(component, event, helper) {  var myClass = component.get(\"v.myApexClass\");   var action = component.get(\"c.setApexClassType\");  action.setParams({ \"myApexClass\" : JSON.stringify(myClass) });  action.setCallback(this, function(response) {     var state = response.getState();    if (state === \u201cSUCCESS\u201d) {      // Do stuff    }     else {      console.log(state);    }  }); $A.enqueueAction(action);}action.setParams({ wrap :  Server-side Controller @AuraEnabledpublic static void setApexClassType(String myApexClass) {  NewWrapperClass nwc = (NewWrapperClass)JSON.deserialize(myApexClass, NewWrapperClass.class);} Set You won\u2019t be able to use a Set, but at least you won\u2019t have any surprise with this one. Try to save an AuraEnabled method with a parameter of type Set<String>, and you\u2019ll see the following error message, preventing you to save: Parameter type does not support AuraEnabled: Set<String>. List and Map are working perfectly though. Bonus tip:\u00a0base64 This is something that is not specific to Lightning, but that may be useful if you want to pass a file to your Apex method. Don\u2019t forget to encode/decode the file: Client-side Controller var action = component.get(\"c.setFile\");action.setParams({ myBase64File : encodeURIComponent(base64File) });action.setCallback(this, function(response) {   var state = response.getState();  if (state === \u201cSUCCESS\u201d) {    // Do stuff  }   else {   console.log(state);  }});$A.enqueueAction(action); Server-side Controller @AuraEnabledpublic static void setFile(String myBase64File) {  String myFile = EncodingUtil.urlDecode(myBase64File, \u2018UTF-8\u2019);} Wrapping up Lightning is still a young framework, and I\u2019m sure most of the strange behaviors described here will be fixed in the future. However in the meantime, I hope this will help some of you save the time I\u2019ve lost when I encountered them. Also, if you\u2019ve seen some other weird things I would have missed with other types, please feel free to add them in the comments. ", "name": "987", "child": "987_1\t987_2\t987_3\t987_4", "timestamp": "Apr 9"}