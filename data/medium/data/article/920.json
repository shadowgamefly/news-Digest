{"name": "920", "parent": "", "content": "That time I had to crack my own Reddit\u00a0password (Kinda.) I have no self-control. Luckily, I know this about myself. This allows me to consciously engineer my life so that despite having the emotional maturity of a heroin-addicted lab rat, I\u2019m occasionally able to get things done. Mm, a waste of time! I waste a lot of time on Reddit. If I want to procrastinate on something, I\u2019ll often open a new tab and dive down a Reddit-hole. But sometimes you need to turn on the blinders and dial down distractions. 2015 was one of these times\u200a\u2014\u200aI was singularly focused on improving as a programmer, and Redditing was becoming a liability. I needed an abstinence plan. So it occurred to me: how about I lock myself out of my account? Here\u2019s what I did: I set a random password on my account. Then I asked a friend to e-mail me this password on a certain date. With that, I\u2019d have a foolproof way to lock myself out of Reddit. (Also changed the e-mail for password recovery to cover all the bases.) This should have worked. Unfortunately it turns out, friends are very susceptible to social engineering. The technical terminology for this is that they are \u201cnice to you\u201d and will give you back your password if you \u201cbeg them.\u201d Don\u2019t look at me like that. After a few rounds of this failure mode, I needed a more robust solution. A little Google searching, and I came across this: Looks legit. Perfect\u200a\u2014\u200aan automated, friend-less solution! (I\u2019d alienated most of them by now, so that was a big selling point.) A bit sketchy looking, but hey, any port in a storm. For a while I set this up this routine\u200a\u2014\u200aduring the week I\u2019d e-mail myself my password, on the weekends I\u2019d receive the password, load up on internet junk food, and then lock myself out again once the week began. It worked quite well from what I remember. Eventually I got so busy with programming stuff, I completely forgot about it. Cut to two years\u00a0later. I\u2019m now gainfully employed at Airbnb. And Airbnb, it so happens, has a large test suite. This means waiting, and waiting of course means internet rabbit holes. I decide to scrounge up my old account and find my Reddit password. Oh no. That\u2019s not good. I didn\u2019t remember doing this, but I must have gotten so fed up with myself that I locked myself out until 2018. I also set it to \u201chide,\u201d so I couldn\u2019t view the contents of the e-mail until it\u2019s sent. What do I do? Do I just have to create a new Reddit account and start from scratch? But that\u2019s so much work. I could write in to LetterMeLater and explain that I didn\u2019t mean to do this. But they would probably take a while to get back to me. We\u2019ve already established I\u2019m wildly impatient. Plus this site doesn\u2019t look like it has a support team. Not to mention it would be an embarrassing e-mail exchange. I started brainstorming elaborate explanations involving dead relatives about why I needed access to the e-mail\u2026 All of my options were messy. I was walking home that night from the office pondering my predicament, when suddenly it hit me. The search bar. I pulled up the app on my mobile phone and tried it: Hmm. Okay. So it\u2019s indexing the subject for sure. What about the body? I try a few letters, and voila. It\u2019s definitely got the body indexed. Remember: the body consisted entirely of my password. Essentially, I\u2019ve been given an interface to perform substring queries. By entering in a string into the search bar, the search results will confirm whether my password contains this substring. We\u2019re in business. I hurry into my apartment, drop my bag, and pull out my laptop. Algorithms problem: you are given a function substring?(str), which returns true or false depending on whether a password contains any given substring. Given this function, write an algorithm that can deduce the hidden password. The Algorithm So let\u2019s think about this. A few things I know about my password: I know it was a long string with some random characters, probably something along the lines of asgoihej2409g. I probably didn\u2019t include any upper-case characters (and Reddit doesn\u2019t enforce that as a password constraint) so let\u2019s assume for now that I didn\u2019t\u200a\u2014\u200ain case I did, we can just expand the search space later if the initial algorithm fails. We also have a subject line as part of the string we\u2019re querying. And we know the subject is \u201cpassword\u201d. Let\u2019s pretend the body is 6 characters long. So we\u2019ve got six slots of characters, some of which may appear in the subject line, some of which certainly don\u2019t. So if we take all of the characters that aren\u2019t in the subject and try searching for each of them, we know for sure we\u2019ll hit a unique letter that\u2019s in the password. Think like a game of Wheel of Fortune. We keep trying letters one by one until we hit a match for something that\u2019s not in our subject line. Say we hit it. Once I\u2019ve found my first letter, I don\u2019t actually know where in this string I am. But I know I can start building out a bigger substring by appending different characters to the end of this until I hit another substring match. We\u2019ll potentially have to iterate through every character in our alphabet to find it. Any of those characters could be correct, so on average it\u2019ll hit somewhere around the middle, so given an alphabet of size A, it should average out to A/2 guesses per letter (let\u2019s assume the subject is small and there are no repeating patterns of 2+ characters). I\u2019ll keep building this substring until it eventually hits the end and no characters can extend it further. But that\u2019s not enough\u200a\u2014\u200amost likely, there will be a prefix to the string that I missed, because I started in a random place. Easy enough: all I have to do is now repeat the process, except going backwards. Once the process terminates, I should be able to reconstruct the password. In total, I\u2019ll need to figure outL characters(where L is the length), and need to expend on average A/2 guesses per character (where A is the alphabet size), so total guesses = A/2 * L. To be precise, I also have to add another 2A to the number of guesses for ascertaining that the string has terminated on each end. So the total is A/2 * L + 2A, which we can factor as A(L/2 + 2). Let\u2019s assume we have 20 characters in our password, and an alphabet consisting of a-z (26) and 0\u20139 (10), so a total alphabet size of 36. So we\u2019re looking at an average of 36 * (20/2 + 2) = 36 * 12 = 432 iterations. Damn. This is actually doable. Programming IRL The Implementation First things first: I need to write a client that can programmatically query the search box. This will serve as my substring oracle. Obviously this site has no API, so I\u2019ll need to scrape the website directly. Looks like the URL format for searching is just a simple query string, www.lettermelater.com/account.php?qe=#{query_here}. That\u2019s easy enough. Let\u2019s start writing this script. I\u2019m going to use the Faraday gem for making web requests, since it has a simple interface that I know well. I\u2019ll start by making an API class. Of course, we don\u2019t expect this to work yet, as our script won\u2019t be authenticated into any account. As we can see, the response returns a 302 redirect with an error message provided in the cookie. [10] pry(main)> Api.get(\u201cfoo\u201d) => #<Faraday::Response:0x007fc01a5716d8 ... {\u201cdate\u201d=>\u201dTue, 04 Apr 2017 15:35:07 GMT\u201d, \u201cserver\u201d=>\u201dApache\u201d, \u201cx-powered-by\u201d=>\u201dPHP/5.2.17\", \u201cset-cookie\u201d=>\u201dmsg_error=You+must+be+signed+in+to+see+this+page.\u201d, \u201clocation\u201d=>\u201d.?pg=account.php\u201d, \u201ccontent-length\u201d=>\u201d0\", \u201cconnection\u201d=>\u201dclose\u201d, \u201ccontent-type\u201d=>\u201dtext/html; charset=utf-8\"}, status=302> So how do we sign in? We need to send in our cookies in the header, of course. Using Chrome inspector we can trivially grab them. (Not going to show my real cookie here, obviously. Interestingly, looks like it\u2019s storing user_id client-side which is always a great sign.) Through process of elimination, I realize that it needs both code and user_id to authenticate me\u2026 sigh. So I add these to the script. (This is a fake cookie, just for illustration.) [29] pry(main)> Api.get(\u201cfoo\u201d)=> \u201c\\n<!DOCTYPE HTML PUBLIC \\\u201d-//W3C//DTD HTML 4.01//EN\\\u201d \\\u201dhttp://www.w3.org/TR/html4/strict.dtd\\\">\\n<html>\\n<head>\\n\\t<meta http-equiv=\\\u201dcontent-type\\\u201d content=\\\u201dtext/html; charset=UTF-8\\\u201d />\\n\\t<meta name=\\\u201dDescription\\\u201d content=\\\u201dLetterMeLater.com allows you to send emails to anyone, with the ability to have them sent at any future date and time you choose.\\\u201d />\\n\\t<meta name=\\\u201dkeywords\\\u201d content=\\\u201dschedule email, recurring, repeating, delayed, text messaging, delivery, later, future, reminder, date, time, capsule\\\u201d />\\n\\t<title>LetterMeLater.com \u2014 Account Information</title>\u2026 [30] pry(main)> _.include?(\u201cHaseeb\u201d)=> true It\u2019s got my name in there, so we\u2019re definitely logged in! We\u2019ve got the scraping down, now we just have to parse the result. Luckily, this pretty easy\u200a\u2014\u200awe know it\u2019s a hit if the e-mail result shows up on the page, so we just need to look for any string that\u2019s unique when the result is present. The string \u201cpassword\u201d appears nowhere else, so that will do just nicely. That\u2019s all we need for our API class. We can now do substring queries entirely in Ruby. [31] pry(main)> Api.include?('password') => true [32] pry(main)> Api.include?('f') => false [33] pry(main)> Api.include?('g') => true Now that we know that works, let\u2019s stub out the API while we develop our algorithm. Making HTTP requests is going to be really slow and we might trigger some rate-limiting as we\u2019re experimenting. If we assume our API is correct, once we get the rest of the algorithm working, everything should just work once we swap the real API back in. So here\u2019s the stubbed API, with a random secret string: We\u2019ll inject the stubbed API into the class while we\u2019re testing. Then for the final run, we\u2019ll use the real API to query for the real password. So let\u2019s get started with this class. From a high level, recalling my algorithm diagram, it goes in three steps: Then we\u2019re done! Let\u2019s start with initialization. We\u2019ll inject the API, and other than that we just need to initialize the current password chunk to be an empty string. Now let\u2019s write three methods, following the steps we outlined. Perfect. Now the rest of the implementation can take place in private methods. For finding the first letter, we need to iterate over each character in the alphabet that\u2019s not contained in the subject. To construct this alphabet, we\u2019re going to use a-z and 0\u20139. Ruby allows us to do this pretty easily with ranges: ALPHABET = ((\u2018a\u2019..\u2019z\u2019).to_a + (\u20180\u2019..\u20199').to_a).shuffle I prefer to shuffle this to remove any bias in the password\u2019s letter distribution. This will make our algorithm query A/2 times on average per character, even if the password is non-randomly distributed. We also want to set the subject as a constant: SUBJECT = \u2018password\u2019 That\u2019s all the setup we need. Now time to write find_starting_letter. This needs to iterate through each candidate letter (in the alphabet but not in the subject) until it finds a match. In testing, looks like this works perfectly: PasswordCracker.new(ApiStub).send(:find_starting_letter!) # => 'f' Now for the heavy lifting. I\u2019m going to do this recursively, because it makes the structure very elegant. The code is surprisingly straightforward. Let\u2019s see if it works with our stub API. [63] pry(main)> PasswordCracker.new(ApiStub).crack! f fj fjp fjpe fjpef fjpefo fjpefoj fjpefoj4 fjpefoj49 fjpefoj490 fjpefoj490r fjpefoj490rj fjpefoj490rjg fjpefoj490rjgs fjpefoj490rjgsd => \u201cfjpefoj490rjgsd\u201d Awesome. We\u2019ve got a suffix, now just to build backward and complete the string. This should look very similar. In fact, there\u2019s only two lines of difference here: how we construct the guess, and the name of the recursive call. There\u2019s an obvious refactoring here, so let\u2019s do it. Now these other calls simply reduce to: And let\u2019s see how it works in action: Apps-MacBook:password-recovery haseeb$ ruby letter_me_now.rb Current password: 9 Current password: 90 Current password: 90r Current password: 90rj Current password: 90rjg Current password: 90rjgs Current password: 90rjgsd Current password: 90rjgsd Current password: 490rjgsd Current password: j490rjgsd Current password: oj490rjgsd Current password: foj490rjgsd Current password: efoj490rjgsd Current password: pefoj490rjgsd Current password: jpefoj490rjgsd Current password: fjpefoj490rjgsd Current password: pfjpefoj490rjgsd Current password: hpfjpefoj490rjgsd Current password: 0hpfjpefoj490rjgsd Current password: 20hpfjpefoj490rjgsd Current password: 420hpfjpefoj490rjgsd Current password: g420hpfjpefoj490rjgsd g420hpfjpefoj490rjgsd Beautiful. Now let\u2019s just add some more print statements and a bit of extra logging, and we\u2019ll have our finished PasswordCracker. And now\u2026 the magic moment. Let\u2019s swap the stub with the real API and see what happens. The Moment of\u00a0Truth Cross your fingers\u2026 PasswordCracker.new(Api).crack! (Sped up\u00a03x) Boom. 443 iterations. Tried it out on Reddit, and login was successful. Wow. It\u2026 actually worked. Recall our original formula for the number of iterations: A(N/2 + 2). The true password was 22 characters, so our formula would estimate 36 * (22/2 + 2) = 36 * 13 = 468 iterations. Our real password took 443 iterations, so our estimate was within 5% of the observed runtime. Math. tfw wtf ftw It works. Embarrassing support e-mail averted. Reddit rabbit-holing restored. It\u2019s now confirmed: programming is, indeed, magic. (The downside is I am now going to have to find a new technique to lock myself out of my accounts.) And with that, I\u2019m gonna get back to my internet rabbit-holes. Thanks for reading, and give it a like if you enjoyed this! \u2014Haseeb ", "title": "That time I had to crack my own Reddit\u00a0password", "sentences": [{"c98e": "That time I had to crack my own Reddit\u00a0password"}, {"7e3a": "(Kinda.)"}, {"b890": "I have no self-control."}, {"ba81": "Luckily, I know this about myself. This allows me to consciously engineer my life so that despite having the emotional maturity of a heroin-addicted lab rat, I\u2019m occasionally able to get things done."}, {"33fb": "Mm, a waste of time!"}, {"88e8": "I waste a lot of time on Reddit. If I want to procrastinate on something, I\u2019ll often open a new tab and dive down a Reddit-hole. But sometimes you need to turn on the blinders and dial down distractions. 2015 was one of these times\u200a\u2014\u200aI was singularly focused on improving as a programmer, and Redditing was becoming a liability."}, {"8821": "I needed an abstinence plan."}, {"52b7": "So it occurred to me: how about I lock myself out of my account?"}, {"b8e2": "Here\u2019s what I did:"}, {"4ea1": "I set a random password on my account. Then I asked a friend to e-mail me this password on a certain date. With that, I\u2019d have a foolproof way to lock myself out of Reddit. (Also changed the e-mail for password recovery to cover all the bases.)"}, {"2312": "This should have worked."}, {"d689": "Unfortunately it turns out, friends are very susceptible to social engineering. The technical terminology for this is that they are \u201cnice to you\u201d and will give you back your password if you \u201cbeg them.\u201d"}, {"e949": "Don\u2019t look at me like that."}, {"8d59": "After a few rounds of this failure mode, I needed a more robust solution. A little Google searching, and I came across this:"}, {"f557": "Looks legit."}, {"3372": "Perfect\u200a\u2014\u200aan automated, friend-less solution! (I\u2019d alienated most of them by now, so that was a big selling point.)"}, {"d61f": "A bit sketchy looking, but hey, any port in a storm."}, {"c68b": "For a while I set this up this routine\u200a\u2014\u200aduring the week I\u2019d e-mail myself my password, on the weekends I\u2019d receive the password, load up on internet junk food, and then lock myself out again once the week began. It worked quite well from what I remember."}, {"6c9d": "Eventually I got so busy with programming stuff, I completely forgot about it."}, {"b837": "Cut to two years\u00a0later."}, {"8eba": "I\u2019m now gainfully employed at Airbnb. And Airbnb, it so happens, has a large test suite. This means waiting, and waiting of course means internet rabbit holes."}, {"a343": "I decide to scrounge up my old account and find my Reddit password."}, {"9e2c": "Oh no. That\u2019s not good."}, {"bdcd": "I didn\u2019t remember doing this, but I must have gotten so fed up with myself that I locked myself out until 2018. I also set it to \u201chide,\u201d so I couldn\u2019t view the contents of the e-mail until it\u2019s sent."}, {"047e": "What do I do? Do I just have to create a new Reddit account and start from scratch? But that\u2019s so much work."}, {"a1af": "I could write in to LetterMeLater and explain that I didn\u2019t mean to do this. But they would probably take a while to get back to me. We\u2019ve already established I\u2019m wildly impatient. Plus this site doesn\u2019t look like it has a support team. Not to mention it would be an embarrassing e-mail exchange. I started brainstorming elaborate explanations involving dead relatives about why I needed access to the e-mail\u2026"}, {"1117": "All of my options were messy. I was walking home that night from the office pondering my predicament, when suddenly it hit me."}, {"2ee3": "The search bar."}, {"e9f8": "I pulled up the app on my mobile phone and tried it:"}, {"b65b": "Hmm."}, {"aade": "Okay. So it\u2019s indexing the subject for sure. What about the body?"}, {"2a0c": "I try a few letters, and voila. It\u2019s definitely got the body indexed. Remember: the body consisted entirely of my password."}, {"3b80": "Essentially, I\u2019ve been given an interface to perform substring queries. By entering in a string into the search bar, the search results will confirm whether my password contains this substring."}, {"c214": "We\u2019re in business."}, {"4ff5": "I hurry into my apartment, drop my bag, and pull out my laptop."}, {"e33f": "Algorithms problem: you are given a function substring?(str), which returns true or false depending on whether a password contains any given substring. Given this function, write an algorithm that can deduce the hidden password."}, {"0a98": "The Algorithm"}, {"0387": "So let\u2019s think about this. A few things I know about my password: I know it was a long string with some random characters, probably something along the lines of asgoihej2409g. I probably didn\u2019t include any upper-case characters (and Reddit doesn\u2019t enforce that as a password constraint) so let\u2019s assume for now that I didn\u2019t\u200a\u2014\u200ain case I did, we can just expand the search space later if the initial algorithm fails."}, {"9cf8": "We also have a subject line as part of the string we\u2019re querying. And we know the subject is \u201cpassword\u201d."}, {"d183": "Let\u2019s pretend the body is 6 characters long. So we\u2019ve got six slots of characters, some of which may appear in the subject line, some of which certainly don\u2019t. So if we take all of the characters that aren\u2019t in the subject and try searching for each of them, we know for sure we\u2019ll hit a unique letter that\u2019s in the password. Think like a game of Wheel of Fortune."}, {"05fc": "We keep trying letters one by one until we hit a match for something that\u2019s not in our subject line. Say we hit it."}, {"e581": "Once I\u2019ve found my first letter, I don\u2019t actually know where in this string I am. But I know I can start building out a bigger substring by appending different characters to the end of this until I hit another substring match."}, {"ea47": "We\u2019ll potentially have to iterate through every character in our alphabet to find it. Any of those characters could be correct, so on average it\u2019ll hit somewhere around the middle, so given an alphabet of size A, it should average out to A/2 guesses per letter (let\u2019s assume the subject is small and there are no repeating patterns of 2+ characters)."}, {"6e7a": "I\u2019ll keep building this substring until it eventually hits the end and no characters can extend it further."}, {"e49e": "But that\u2019s not enough\u200a\u2014\u200amost likely, there will be a prefix to the string that I missed, because I started in a random place. Easy enough: all I have to do is now repeat the process, except going backwards."}, {"4497": "Once the process terminates, I should be able to reconstruct the password. In total, I\u2019ll need to figure outL characters(where L is the length), and need to expend on average A/2 guesses per character (where A is the alphabet size), so total guesses = A/2 * L."}, {"83b0": "To be precise, I also have to add another 2A to the number of guesses for ascertaining that the string has terminated on each end. So the total is A/2 * L + 2A, which we can factor as A(L/2 + 2)."}, {"a8cd": "Let\u2019s assume we have 20 characters in our password, and an alphabet consisting of a-z (26) and 0\u20139 (10), so a total alphabet size of 36. So we\u2019re looking at an average of 36 * (20/2 + 2) = 36 * 12 = 432 iterations."}, {"f0f8": "Damn."}, {"86db": "This is actually doable."}, {"ede1": "Programming IRL"}, {"d884": "The Implementation"}, {"f88d": "First things first: I need to write a client that can programmatically query the search box. This will serve as my substring oracle. Obviously this site has no API, so I\u2019ll need to scrape the website directly."}, {"31a0": "Looks like the URL format for searching is just a simple query string, www.lettermelater.com/account.php?qe=#{query_here}. That\u2019s easy enough."}, {"2ee1": "Let\u2019s start writing this script. I\u2019m going to use the Faraday gem for making web requests, since it has a simple interface that I know well."}, {"b308": "I\u2019ll start by making an API class."}, {"eac7": "Of course, we don\u2019t expect this to work yet, as our script won\u2019t be authenticated into any account. As we can see, the response returns a 302 redirect with an error message provided in the cookie."}, {"a2a0": "[10] pry(main)> Api.get(\u201cfoo\u201d)"}, {"fdce": "=> #<Faraday::Response:0x007fc01a5716d8"}, {"cf8c": "..."}, {"6642": "{\u201cdate\u201d=>\u201dTue, 04 Apr 2017 15:35:07 GMT\u201d,"}, {"a4a3": "\u201cserver\u201d=>\u201dApache\u201d,"}, {"156a": "\u201cx-powered-by\u201d=>\u201dPHP/5.2.17\","}, {"8cc6": "\u201cset-cookie\u201d=>\u201dmsg_error=You+must+be+signed+in+to+see+this+page.\u201d,"}, {"1cd2": "\u201clocation\u201d=>\u201d.?pg=account.php\u201d,"}, {"67ac": "\u201ccontent-length\u201d=>\u201d0\","}, {"f616": "\u201cconnection\u201d=>\u201dclose\u201d,"}, {"4e65": "\u201ccontent-type\u201d=>\u201dtext/html; charset=utf-8\"},"}, {"127e": "status=302>"}, {"53c5": "So how do we sign in? We need to send in our cookies in the header, of course. Using Chrome inspector we can trivially grab them."}, {"7607": "(Not going to show my real cookie here, obviously. Interestingly, looks like it\u2019s storing user_id client-side which is always a great sign.)"}, {"cb56": "Through process of elimination, I realize that it needs both code and user_id to authenticate me\u2026 sigh."}, {"aa8d": "So I add these to the script. (This is a fake cookie, just for illustration.)"}, {"4900": "[29] pry(main)> Api.get(\u201cfoo\u201d)=> \u201c\\n<!DOCTYPE HTML PUBLIC \\\u201d-//W3C//DTD HTML 4.01//EN\\\u201d \\\u201dhttp://www.w3.org/TR/html4/strict.dtd\\\">\\n<html>\\n<head>\\n\\t<meta http-equiv=\\\u201dcontent-type\\\u201d content=\\\u201dtext/html; charset=UTF-8\\\u201d />\\n\\t<meta name=\\\u201dDescription\\\u201d content=\\\u201dLetterMeLater.com allows you to send emails to anyone, with the ability to have them sent at any future date and time you choose.\\\u201d />\\n\\t<meta name=\\\u201dkeywords\\\u201d content=\\\u201dschedule email, recurring, repeating, delayed, text messaging, delivery, later, future, reminder, date, time, capsule\\\u201d />\\n\\t<title>LetterMeLater.com \u2014 Account Information</title>\u2026"}, {"6983": "[30] pry(main)> _.include?(\u201cHaseeb\u201d)=> true"}, {"4949": "It\u2019s got my name in there, so we\u2019re definitely logged in!"}, {"9c69": "We\u2019ve got the scraping down, now we just have to parse the result. Luckily, this pretty easy\u200a\u2014\u200awe know it\u2019s a hit if the e-mail result shows up on the page, so we just need to look for any string that\u2019s unique when the result is present. The string \u201cpassword\u201d appears nowhere else, so that will do just nicely."}, {"fa88": "That\u2019s all we need for our API class. We can now do substring queries entirely in Ruby."}, {"dcf0": "[31] pry(main)> Api.include?('password')"}, {"43ef": "=> true"}, {"3288": "[32] pry(main)> Api.include?('f')"}, {"5c3b": "=> false"}, {"fc66": "[33] pry(main)> Api.include?('g')"}, {"47b1": "=> true"}, {"2063": "Now that we know that works, let\u2019s stub out the API while we develop our algorithm. Making HTTP requests is going to be really slow and we might trigger some rate-limiting as we\u2019re experimenting. If we assume our API is correct, once we get the rest of the algorithm working, everything should just work once we swap the real API back in."}, {"2955": "So here\u2019s the stubbed API, with a random secret string:"}, {"0bd6": "We\u2019ll inject the stubbed API into the class while we\u2019re testing. Then for the final run, we\u2019ll use the real API to query for the real password."}, {"f680": "So let\u2019s get started with this class. From a high level, recalling my algorithm diagram, it goes in three steps:"}, {"c564": "Then we\u2019re done!"}, {"1b83": "Let\u2019s start with initialization. We\u2019ll inject the API, and other than that we just need to initialize the current password chunk to be an empty string."}, {"6790": "Now let\u2019s write three methods, following the steps we outlined."}, {"95bb": "Perfect. Now the rest of the implementation can take place in private methods."}, {"6fb6": "For finding the first letter, we need to iterate over each character in the alphabet that\u2019s not contained in the subject. To construct this alphabet, we\u2019re going to use a-z and 0\u20139. Ruby allows us to do this pretty easily with ranges:"}, {"acfe": "ALPHABET = ((\u2018a\u2019..\u2019z\u2019).to_a + (\u20180\u2019..\u20199').to_a).shuffle"}, {"2c75": "I prefer to shuffle this to remove any bias in the password\u2019s letter distribution. This will make our algorithm query A/2 times on average per character, even if the password is non-randomly distributed."}, {"f857": "We also want to set the subject as a constant:"}, {"edcb": "SUBJECT = \u2018password\u2019"}, {"d7ea": "That\u2019s all the setup we need. Now time to write find_starting_letter. This needs to iterate through each candidate letter (in the alphabet but not in the subject) until it finds a match."}, {"ff5b": "In testing, looks like this works perfectly:"}, {"73a5": "PasswordCracker.new(ApiStub).send(:find_starting_letter!) # => 'f'"}, {"df3f": "Now for the heavy lifting."}, {"c424": "I\u2019m going to do this recursively, because it makes the structure very elegant."}, {"8001": "The code is surprisingly straightforward. Let\u2019s see if it works with our stub API."}, {"adf4": "[63] pry(main)> PasswordCracker.new(ApiStub).crack!"}, {"ce5d": "f"}, {"5f66": "fj"}, {"594a": "fjp"}, {"ee9e": "fjpe"}, {"3bd8": "fjpef"}, {"7661": "fjpefo"}, {"5438": "fjpefoj"}, {"7750": "fjpefoj4"}, {"a580": "fjpefoj49"}, {"f814": "fjpefoj490"}, {"c4d4": "fjpefoj490r"}, {"8ae3": "fjpefoj490rj"}, {"4a2b": "fjpefoj490rjg"}, {"05cc": "fjpefoj490rjgs"}, {"8b98": "fjpefoj490rjgsd"}, {"0dd5": "=> \u201cfjpefoj490rjgsd\u201d"}, {"c15d": "Awesome. We\u2019ve got a suffix, now just to build backward and complete the string. This should look very similar."}, {"d307": "In fact, there\u2019s only two lines of difference here: how we construct the guess, and the name of the recursive call. There\u2019s an obvious refactoring here, so let\u2019s do it."}, {"edda": "Now these other calls simply reduce to:"}, {"31bd": "And let\u2019s see how it works in action:"}, {"1ff0": "Apps-MacBook:password-recovery haseeb$ ruby letter_me_now.rb"}, {"9841": "Current password: 9"}, {"faed": "Current password: 90"}, {"928a": "Current password: 90r"}, {"b175": "Current password: 90rj"}, {"27c3": "Current password: 90rjg"}, {"6c6a": "Current password: 90rjgs"}, {"e68e": "Current password: 90rjgsd"}, {"eec7": "Current password: 90rjgsd"}, {"2003": "Current password: 490rjgsd"}, {"4a59": "Current password: j490rjgsd"}, {"93bb": "Current password: oj490rjgsd"}, {"6acd": "Current password: foj490rjgsd"}, {"923c": "Current password: efoj490rjgsd"}, {"48de": "Current password: pefoj490rjgsd"}, {"443f": "Current password: jpefoj490rjgsd"}, {"8570": "Current password: fjpefoj490rjgsd"}, {"3897": "Current password: pfjpefoj490rjgsd"}, {"c77b": "Current password: hpfjpefoj490rjgsd"}, {"e6ff": "Current password: 0hpfjpefoj490rjgsd"}, {"6473": "Current password: 20hpfjpefoj490rjgsd"}, {"f700": "Current password: 420hpfjpefoj490rjgsd"}, {"bd54": "Current password: g420hpfjpefoj490rjgsd"}, {"5bf4": "g420hpfjpefoj490rjgsd"}, {"f492": "Beautiful. Now let\u2019s just add some more print statements and a bit of extra logging, and we\u2019ll have our finished PasswordCracker."}, {"cbe0": "And now\u2026 the magic moment. Let\u2019s swap the stub with the real API and see what happens."}, {"2a00": "The Moment of\u00a0Truth"}, {"d7cf": "Cross your fingers\u2026"}, {"0215": "PasswordCracker.new(Api).crack!"}, {"3fd8": "(Sped up\u00a03x)"}, {"356a": "Boom. 443 iterations."}, {"cddd": "Tried it out on Reddit, and login was successful."}, {"0977": "Wow."}, {"5035": "It\u2026 actually worked."}, {"a929": "Recall our original formula for the number of iterations: A(N/2 + 2). The true password was 22 characters, so our formula would estimate 36 * (22/2 + 2) = 36 * 13 = 468 iterations. Our real password took 443 iterations, so our estimate was within 5% of the observed runtime."}, {"5d23": "Math."}, {"827d": "tfw wtf ftw"}, {"bc5e": "It works."}, {"ed17": "Embarrassing support e-mail averted. Reddit rabbit-holing restored. It\u2019s now confirmed: programming is, indeed, magic."}, {"c3a0": "(The downside is I am now going to have to find a new technique to lock myself out of my accounts.)"}, {"1646": "And with that, I\u2019m gonna get back to my internet rabbit-holes. Thanks for reading, and give it a like if you enjoyed this!"}, {"2198": "\u2014Haseeb"}], "child": "920_1\t920_2\t920_3\t920_4\t920_5\t920_6\t920_7\t920_8\t920_9\t920_10\t920_11\t920_12\t920_13\t920_14\t920_15\t920_16\t920_17\t920_18\t920_19\t920_20\t920_21\t920_22\t920_23\t920_24\t920_25"}