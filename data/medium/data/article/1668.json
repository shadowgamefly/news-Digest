{"name": "1668", "parent": "", "content": "A step-by-step guide to building a simple chess\u00a0AI Let\u2019s explore some basic concepts that will help us create a simple chess AI: At each step, we\u2019ll improve our algorithm with one of these time-tested chess-programming techniques. I\u2019ll demonstrate how each affects the algorithm\u2019s playing style. You can view the final AI algorithm here on GitHub. Step 1: Move generation and board visualization We\u2019ll use the chess.js library for move generation, and chessboard.js for visualizing the board. The move generation library basically implements all the rules of chess. Based on this, we can calculate all legal moves for a given board state. Using these libraries will help us focus only on the most interesting task: creating the algorithm that finds the best move. We\u2019ll start by creating a function that just returns a random move from all of the possible moves: Although this algorithm isn\u2019t a very solid chess player, it\u2019s a good starting point, as we can actually play against it: Black plays random moves. Playable on https://jsfiddle.net/lhartikk/m14epfwb/4 Step 2\u00a0: Position evaluation Now let\u2019s try to understand which side is stronger in a certain position. The simplest way to achieve this is to count the relative strength of the pieces on the board using the following table: With the evaluation function, we\u2019re able to create an algorithm that chooses the move that gives the highest evaluation: The only tangible improvement is that our algorithm will now capture a piece if it can. Black plays with the aid of the simple evaluation function. Playable on https://jsfiddle.net/lhartikk/m5q6fgtb/1/ Step 3: Search tree using\u00a0Minimax Next we\u2019re going to create a search tree from which the algorithm can chose the best move. This is done by using the Minimax algorithm. In this algorithm, the recursive tree of all possible moves is explored to a given depth, and the position is evaluated at the ending \u201cleaves\u201d of the tree. After that, we return either the smallest or the largest value of the child to the parent node, depending on whether it\u2019s a white or black to move. (That is, we try to either minimize or maximize the outcome at each level.) A visualization of the minimax algorithm in an artificial position. The best move for white is b2-c3, because we can guarantee that we can get to a position where the evaluation is\u00a0-50 With minimax in place, our algorithm is starting to understand some basic tactics of chess: Minimax with depth level 2. Playable on: https://jsfiddle.net/k96eoq0q/1/ The effectiveness of the minimax algorithm is heavily based on the search depth we can achieve. This is something we\u2019ll improve in the following step. Step 4: Alpha-beta pruning Alpha-beta pruning is an optimization method to the minimax algorithm that allows us to disregard some branches in the search tree. This helps us evaluate the minimax search tree much deeper, while using the same resources. The alpha-beta pruning is based on the situation where we can stop evaluating a part of the search tree if we find a move that leads to a worse situation than a previously discovered move. The alpha-beta pruning does not influence the outcome of the minimax algorithm\u200a\u2014\u200ait only makes it faster. The alpha-beta algorithm also is more efficient if we happen to visit first those paths that lead to good moves. The positions we do not need to explore if alpha-beta pruning isused and the tree is visited in the described order. With alpha-beta, we get a significant boost to the minimax algorithm, as is shown in the following example: The number of positions that are required to evaluate if we want to perform a search with depth of 4 and the \u201croot\u201d position is the one that is\u00a0shown. Follow this link to try the alpha-beta improved version of the chess AI. Step 5: Improved evaluation function The initial evaluation function is quite naive as we only count the material that is found on the board. To improve this, we add to the evaluation a factor that takes in account the position of the pieces. For example, a knight on the center of the board is better (because it has more options and is thus more active) than a knight on the edge of the board. We\u2019ll use a slightly adjusted version of piece-square tables that are originally described in the chess-programming-wiki. The visualized piece-square tables visualized. We can decrease or increase the evaluation, depending on the location of the\u00a0piece. With the following improvement, we start to get an algorithm that plays some \u201cdecent\u201d chess, at least from the viewpoint of a casual player: Improved evaluation and alpha-beta pruning with search depth of 3. Playable on https://jsfiddle.net/q76uzxwe/1/ Conclusions The strength of even a simple chess-playing algorithm is that it doesn\u2019t make stupid mistakes. This said, it still lacks strategic understanding. With the methods I introduced here, we\u2019ve been able to program a chess-playing-algorithm that can play basic chess. The \u201cAI-part\u201d (move-generation excluded) of the final algorithm is just 200 lines of code, meaning the basic concepts are quite simple to implement. You can check out the final version is on GitHub. Some further improvements we could make to the algorithm would be for instance: If you want to learn more, check out the chess programming wiki. It\u2019s a helpful resource for exploring beyond these basic concepts I introduced here. Thanks for reading! ", "title": "A step-by-step guide to building a simple chess\u00a0AI", "sentences": [{"f4aa": "A step-by-step guide to building a simple chess\u00a0AI"}, {"c58b": "Let\u2019s explore some basic concepts that will help us create a simple chess AI:"}, {"0011": "At each step, we\u2019ll improve our algorithm with one of these time-tested chess-programming techniques. I\u2019ll demonstrate how each affects the algorithm\u2019s playing style."}, {"7ae9": "You can view the final AI algorithm here on GitHub."}, {"df0f": "Step 1: Move generation and board visualization"}, {"e40f": "We\u2019ll use the chess.js library for move generation, and chessboard.js for visualizing the board. The move generation library basically implements all the rules of chess. Based on this, we can calculate all legal moves for a given board state."}, {"7bd7": "Using these libraries will help us focus only on the most interesting task: creating the algorithm that finds the best move."}, {"7736": "We\u2019ll start by creating a function that just returns a random move from all of the possible moves:"}, {"1975": "Although this algorithm isn\u2019t a very solid chess player, it\u2019s a good starting point, as we can actually play against it:"}, {"a842": "Black plays random moves. Playable on https://jsfiddle.net/lhartikk/m14epfwb/4"}, {"48f7": "Step 2\u00a0: Position evaluation"}, {"518f": "Now let\u2019s try to understand which side is stronger in a certain position. The simplest way to achieve this is to count the relative strength of the pieces on the board using the following table:"}, {"8bf3": "With the evaluation function, we\u2019re able to create an algorithm that chooses the move that gives the highest evaluation:"}, {"302b": "The only tangible improvement is that our algorithm will now capture a piece if it can."}, {"8660": "Black plays with the aid of the simple evaluation function. Playable on https://jsfiddle.net/lhartikk/m5q6fgtb/1/"}, {"5b99": "Step 3: Search tree using\u00a0Minimax"}, {"fd0b": "Next we\u2019re going to create a search tree from which the algorithm can chose the best move. This is done by using the Minimax algorithm."}, {"2277": "In this algorithm, the recursive tree of all possible moves is explored to a given depth, and the position is evaluated at the ending \u201cleaves\u201d of the tree."}, {"5c63": "After that, we return either the smallest or the largest value of the child to the parent node, depending on whether it\u2019s a white or black to move. (That is, we try to either minimize or maximize the outcome at each level.)"}, {"1cdb": "A visualization of the minimax algorithm in an artificial position. The best move for white is b2-c3, because we can guarantee that we can get to a position where the evaluation is\u00a0-50"}, {"83a2": "With minimax in place, our algorithm is starting to understand some basic tactics of chess:"}, {"084d": "Minimax with depth level 2. Playable on: https://jsfiddle.net/k96eoq0q/1/"}, {"b3fe": "The effectiveness of the minimax algorithm is heavily based on the search depth we can achieve. This is something we\u2019ll improve in the following step."}, {"b9df": "Step 4: Alpha-beta pruning"}, {"f3ea": "Alpha-beta pruning is an optimization method to the minimax algorithm that allows us to disregard some branches in the search tree. This helps us evaluate the minimax search tree much deeper, while using the same resources."}, {"0ff2": "The alpha-beta pruning is based on the situation where we can stop evaluating a part of the search tree if we find a move that leads to a worse situation than a previously discovered move."}, {"4b9f": "The alpha-beta pruning does not influence the outcome of the minimax algorithm\u200a\u2014\u200ait only makes it faster."}, {"9b96": "The alpha-beta algorithm also is more efficient if we happen to visit first those paths that lead to good moves."}, {"2001": "The positions we do not need to explore if alpha-beta pruning isused and the tree is visited in the described order."}, {"787f": "With alpha-beta, we get a significant boost to the minimax algorithm, as is shown in the following example:"}, {"4aba": "The number of positions that are required to evaluate if we want to perform a search with depth of 4 and the \u201croot\u201d position is the one that is\u00a0shown."}, {"8203": "Follow this link to try the alpha-beta improved version of the chess AI."}, {"ca68": "Step 5: Improved evaluation function"}, {"21d1": "The initial evaluation function is quite naive as we only count the material that is found on the board. To improve this, we add to the evaluation a factor that takes in account the position of the pieces. For example, a knight on the center of the board is better (because it has more options and is thus more active) than a knight on the edge of the board."}, {"6b95": "We\u2019ll use a slightly adjusted version of piece-square tables that are originally described in the chess-programming-wiki."}, {"aa7f": "The visualized piece-square tables visualized. We can decrease or increase the evaluation, depending on the location of the\u00a0piece."}, {"e510": "With the following improvement, we start to get an algorithm that plays some \u201cdecent\u201d chess, at least from the viewpoint of a casual player:"}, {"b1fb": "Improved evaluation and alpha-beta pruning with search depth of 3. Playable on https://jsfiddle.net/q76uzxwe/1/"}, {"895a": "Conclusions"}, {"8da8": "The strength of even a simple chess-playing algorithm is that it doesn\u2019t make stupid mistakes. This said, it still lacks strategic understanding."}, {"ade5": "With the methods I introduced here, we\u2019ve been able to program a chess-playing-algorithm that can play basic chess. The \u201cAI-part\u201d (move-generation excluded) of the final algorithm is just 200 lines of code, meaning the basic concepts are quite simple to implement. You can check out the final version is on GitHub."}, {"d181": "Some further improvements we could make to the algorithm would be for instance:"}, {"abdd": "If you want to learn more, check out the chess programming wiki. It\u2019s a helpful resource for exploring beyond these basic concepts I introduced here."}, {"e6e0": "Thanks for reading!"}], "child": "1668_1\t1668_2\t1668_3\t1668_4\t1668_5\t1668_6\t1668_7\t1668_8\t1668_9\t1668_10\t1668_11\t1668_12\t1668_13\t1668_14\t1668_15\t1668_16"}