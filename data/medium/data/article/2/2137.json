{"name": "2137", "title": "Android MVP architecture with Dependency Injection", "sentences": [{"486f": "Android MVP architecture with Dependency Injection"}, {"495b": "Image Credit: https://unsplash.com/@junoless"}, {"c89a": "Design pattern is an addictive topic which will never feed our curiosity enough, because of its beauty in software development."}, {"32b0": "My last post covered the importance of a proper architecture pattern and the introduction of MVP in Android projects. In this article, we are going to leverage our codes by using another design pattern: Dependency Injection."}, {"8cc4": "What is Dependency Injection?"}, {"daf3": "Well, Dependency Injection is a design pattern which is originally mentioned in Martin Fowler\u2019s article. It allows developers to write code that has low coupling and which can therefore be easily tested."}, {"2c9b": "If you are not familiar with Dependency Injection, let\u2019s build basic knowledge first by checking out other resources. I highly recommend Anthony Ferrara\u2019s short video and this intuitive article."}, {"28c2": "Dependency Injection is a really huge topic in software development, so we are not going to cover the whole stuffs about it."}, {"c4c7": "Instead, we are going to see how it works with and complements to MVP architecture in Android project. This is our main focus in this article."}, {"6194": "Why do we need Dependency Injection?"}, {"b150": "As we pointed out that a good architecture makes our apps easy to test and easy to maintain. Dependency Injection also favors this goal. It improves testability and reduce maintenance cost of our \u2018pure\u2019 MVP apps."}, {"6076": "Let\u2019s review the View and the Presenter of the previous MVP example in the last article."}, {"bda1": "A class should not initiate a dependency by itself because it creates a high coupling that will be quite difficult to test. However, in my above codes, the Presenter creates a Model instance inside its constructor, and the View creates a Presenter instance inside its method."}, {"37b4": "How can I use a mock instance of the Model or the Presenter for testing? Sorry, no way.\u00a0:|"}, {"c019": "The solution is that these dependency objects should be \u201cinjected\u201d from outside components like factories or builders."}, {"024e": "How does Dependency Injection work with MVP in\u00a0Android?"}, {"07ae": "To apply Dependency Injection, we can simply understand the pattern and follow its rules to implement it. However, we will struggle with a problem that we will have to write a lot of boilerplate codes and maintain them."}, {"365b": "Fortunately, there is an powerful open-source framework called Dagger out there to support us. It is developed and maintained mainly by engineers from Square and Google. You can find its version 1(deprecated) and version 2 on Github."}, {"0257": "You can setup Dagger in your Android project by following its installation guide on Github page. Let\u2019s see how we apply it."}, {"e5e1": "As mentioned above about MVP sample, we will inject dependencies objects from outside instead of initiating inside the classes. Here is how the code is updated:"}, {"e3e3": "In above codes, I used \u201c@Inject\u201d annotation which is one of fundamental annotations of Dagger. In compiling process, Dagger will look at all of these annotations to create exact dependency objects for you. It sounds amazing, right. It is cool but not a magic tool because it is not enough."}, {"4ba4": "You have to tell Dagger that where and how to get these necessary dependencies. That is the reason why you need two other important guys."}, {"0c7f": "Finally, let\u2019s build them by calling this (in this case, it is inside Activity class)."}, {"4b0d": "We have completed all main steps. For more details, you can visit this Github repository and then checkout \u201cdagger\u201d branch."}, {"fda8": "Hope that this article is useful to you. If you liked this, click the \ud83d\udc9a below so other people will see this here on Medium."}], "child": "2137_1\t2137_2", "timestamp": "Apr 14", "content": "Android MVP architecture with Dependency Injection Image Credit: https://unsplash.com/@junoless Design pattern is an addictive topic which will never feed our curiosity enough, because of its beauty in software development. My last post covered the importance of a proper architecture pattern and the introduction of MVP in Android projects. In this article, we are going to leverage our codes by using another design pattern: Dependency Injection. What is Dependency Injection? Well, Dependency Injection is a design pattern which is originally mentioned in Martin Fowler\u2019s article. It allows developers to write code that has low coupling and which can therefore be easily tested. If you are not familiar with Dependency Injection, let\u2019s build basic knowledge first by checking out other resources. I highly recommend Anthony Ferrara\u2019s short video and this intuitive article. Dependency Injection is a really huge topic in software development, so we are not going to cover the whole stuffs about it. Instead, we are going to see how it works with and complements to MVP architecture in Android project. This is our main focus in this article. Why do we need Dependency Injection? As we pointed out that a good architecture makes our apps easy to test and easy to maintain. Dependency Injection also favors this goal. It improves testability and reduce maintenance cost of our \u2018pure\u2019 MVP apps. Let\u2019s review the View and the Presenter of the previous MVP example in the last article. A class should not initiate a dependency by itself because it creates a high coupling that will be quite difficult to test. However, in my above codes, the Presenter creates a Model instance inside its constructor, and the View creates a Presenter instance inside its method. How can I use a mock instance of the Model or the Presenter for testing? Sorry, no way.\u00a0:| The solution is that these dependency objects should be \u201cinjected\u201d from outside components like factories or builders. How does Dependency Injection work with MVP in\u00a0Android? To apply Dependency Injection, we can simply understand the pattern and follow its rules to implement it. However, we will struggle with a problem that we will have to write a lot of boilerplate codes and maintain them. Fortunately, there is an powerful open-source framework called Dagger out there to support us. It is developed and maintained mainly by engineers from Square and Google. You can find its version 1(deprecated) and version 2 on Github. You can setup Dagger in your Android project by following its installation guide on Github page. Let\u2019s see how we apply it. As mentioned above about MVP sample, we will inject dependencies objects from outside instead of initiating inside the classes. Here is how the code is updated: In above codes, I used \u201c@Inject\u201d annotation which is one of fundamental annotations of Dagger. In compiling process, Dagger will look at all of these annotations to create exact dependency objects for you. It sounds amazing, right. It is cool but not a magic tool because it is not enough. You have to tell Dagger that where and how to get these necessary dependencies. That is the reason why you need two other important guys. Finally, let\u2019s build them by calling this (in this case, it is inside Activity class). We have completed all main steps. For more details, you can visit this Github repository and then checkout \u201cdagger\u201d branch. Hope that this article is useful to you. If you liked this, click the \ud83d\udc9a below so other people will see this here on Medium. ", "author": "Quang Nguyen", "parent": ""}