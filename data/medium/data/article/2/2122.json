{"name": "2122", "title": "Glimmer.js: What\u2019s the Deal with TypeScript?", "sentences": [{"a478": "Glimmer.js: What\u2019s the Deal with TypeScript?"}, {"e652": "Two weeks ago at EmberConf, we announced Glimmer.js, a component-based library for writing superfast web applications."}, {"1361": "In the demo video, we use TypeScript to write our Glimmer components. Some people have been asking, what\u2019s the deal? Have we turned our backs on JavaScript and embraced our new TypeScript overlords?"}, {"3640": "I\u2019m not usually a fan of \u201calternative\u201d JavaScript. All the way back in 2013, for example, I was arguing against adopting CoffeeScript. It was easy to see that there was important new functionality coming in ES6 and beyond, and it wasn\u2019t clear how CoffeeScript users would be able to take advantage of it."}, {"9949": "For example, CoffeeScript adopted for..of loops to iterate over the properties of an object. Meanwhile, ES6 introduced its own for..of loops as a way to loop through iterable objects. If CoffeeScript wants to support new functionality with similar syntax like this, it has two choices: break existing CoffeeScript code, or diverge from JavaScript more and more over time."}, {"8f66": "Because JavaScript is the lingua franca of the web, and the web is everywhere, it is a programming language subject to enormous compatibility constraints. The smallest language change can potentially render millions of sites inoperable."}, {"abaa": "I have witnessed the intense amount of thought and care TC39 members devote to figuring out how to introduce modern language features in a way that is completely backwards-compatible. It involves dumping out all of the existing features and syntax on a table, and painstakingly moving them around until a compatible path can be traced through."}, {"74cf": "Unfortunately, this heroic effort only helps JavaScript, not \u201calt-JavaScript.\u201d At the end of the day, transpiled languages suffer from one of two problems:"}, {"0002": "But not TypeScript. TypeScript is different."}, {"875a": "TypeScript is different because of how radically constrained it is."}, {"730f": "Most transpiled languages exist because they want to correct some perceived deficiencies in JavaScript. It\u2019s hard to quantify, but you can feel the respect that the TypeScript team has for JavaScript. They\u2019re not trying to rescue an inherently flawed language; instead, they\u2019re trying to help a language they love reach new heights."}, {"c25a": "I love TypeScript because the delta between it and JavaScript is so small. In fact, you can take any JavaScript file, change the extension to\u00a0.ts, and boom, you\u2019ve got a valid TypeScript file."}, {"31ab": "Because TypeScript is a superset of JavaScript, you\u2019ve actually been writing TypeScript this whole time."}, {"fb1e": "From there, you can incrementally add type checking only where you think it\u2019s necessary."}, {"008e": "It\u2019s easy for people to have a visceral negative reaction to TypeScript. Let\u2019s be frank: a lot of TypeScript examples are nearly indistinguishable from Java."}, {"acf6": "But two points:"}, {"28ad": "JavaScript + Types = TypeScript"}, {"490c": "For people who haven\u2019t used TypeScript, it\u2019s easy to imagine that it might be a bunch of weird, complicated new stuff on top of JavaScript, in addition to types. In reality, TypeScript is just JavaScript plus the smallest possible set of syntax additions required to let you incrementally typecheck your code."}, {"09d8": "What\u2019s incredible about the TypeScript compiler is that it doesn\u2019t transpile code so much as just strip out type annotations. Debugging is straightforward because each line of TypeScript corresponds to the same line of JavaScript, just without the types."}, {"64b5": "Here\u2019s an example TypeScript file, and the resulting compiled JavaScript (targeting ES2017):"}, {"f8ee": "As you can see, we\u2019re using cutting-edge ES2017 features like async functions, and the syntax is exactly the same across both. The only difference in the TypeScript version is that we declare the fields on the Person class, as well as the type of the arguments to the constructor; these simply disappear in the JavaScript output."}, {"0d3f": "And even these simple annotations quickly begin to pay dividends. For example, using a TypeScript-enabled editor like VS Code gives us detailed information about class properties, just by hovering our mouse over them:"}, {"c29c": "\u201cBut I Still Don\u2019t Want to Use TypeScript!\u201d"}, {"2a85": "And that\u2019s totally cool! Glimmer is a library, first and foremost, for writing JavaScript apps. If you don\u2019t want to use TypeScript, you should have the freedom not to."}, {"f268": "\u201cThat\u2019s what Angular said and look how that turned\u00a0out.\u201d"}, {"b35f": "OK, I guess this is maybe the elephant in the room. A lot of people\u2019s first exposure to TypeScript was Angular 2. Looking at the Angular website, it\u2019s easy to get the sense that using TypeScript means JavaScript becomes a de facto second-class citizen."}, {"d60a": "For example, here\u2019s an Angular component in TypeScript:"}, {"b021": "Here\u2019s the same thing in ES6 JavaScript:"}, {"f0f4": "As you can see, the JavaScript version is quite a bit longer than the TypeScript version. So why wouldn\u2019t Glimmer suffer the same fate?"}, {"fd2b": "The primary reason is that Angular relies on an experimental TypeScript feature that emits type information in the compiled JavaScript (i.e., emitDecoratorMetadata). Dependency injection is front and center in Angular, so they (very rationally) decided to use the types you\u2019d write anyway to power the DI system."}, {"ccdf": "I actually think this is a cool example of improving developer ergonomics in Angular by using existing type information, but it does have the unfortunate effect of requiring different, often awkward APIs for people who want to use JavaScript."}, {"2045": "Glimmer goes in the other direction. We like that TypeScript is just JavaScript, so the APIs you use in both languages are exactly the same. Because Glimmer is written in TypeScript, you get great autocompletion and type checking out of the box, but there\u2019s no requirement to use TypeScript, and there\u2019s no alternate set of APIs for JavaScript."}, {"7050": "After having used TypeScript for nearly a year, I have to confess: I never want to start a new project without it again."}, {"06ed": "Refactors that used to take weeks take days, sometimes less. And because refactoring is so much easier, cleanup that would never have happened becomes\u2026 almost painless."}, {"9d98": "In literally every case, converting a project from JavaScript to TypeScript has identified at least one bug. Because I\u2019m now aware of the kinds of bugs TypeScript catches automatically, writing code without it feels like walking a tight rope without a net."}, {"e493": "Most of all, I continue to be impressed by the professionalism of the TypeScript team. In an ecosystem that can feel built on a house of unmaintained cards, TypeScript\u2019s drumbeat of constant, iterative improvement is refreshing."}, {"cd98": "TypeScript is exploding in popularity and I think it will continue to only get more popular. As I finish writing this post, Felix Rieseberg\u2019s post on using TypeScript at Slack is on the front page of Hacker News. I suspect that most people who try TypeScript will end up liking it."}, {"80a4": "At the end of the day, though, JavaScript is the language of the web. It\u2019s our job to give you a library that feels great whatever you choose."}, {"0f86": "That\u2019s why we design our APIs for JavaScript first, and thanks to TypeScript\u2019s love for JavaScript, it couldn\u2019t be easier."}], "child": "2122_1\t2122_2\t2122_3\t2122_4\t2122_5\t2122_6\t2122_7\t2122_8\t2122_9\t2122_102122_1\t2122_2\t2122_3\t2122_4\t2122_5\t2122_6\t2122_7\t2122_8\t2122_9\t2122_102122_1\t2122_2\t2122_3\t2122_4\t2122_5\t2122_6\t2122_7\t2122_8\t2122_9\t2122_102122_1\t2122_2\t2122_3\t2122_4\t2122_5\t2122_6\t2122_7\t2122_8\t2122_9\t2122_102122_1\t2122_2\t2122_3\t2122_4\t2122_5\t2122_6\t2122_7\t2122_8\t2122_9\t2122_10", "timestamp": "Apr 11", "content": "Glimmer.js: What\u2019s the Deal with TypeScript? Two weeks ago at EmberConf, we announced Glimmer.js, a component-based library for writing superfast web applications. In the demo video, we use TypeScript to write our Glimmer components. Some people have been asking, what\u2019s the deal? Have we turned our backs on JavaScript and embraced our new TypeScript overlords? I\u2019m not usually a fan of \u201calternative\u201d JavaScript. All the way back in 2013, for example, I was arguing against adopting CoffeeScript. It was easy to see that there was important new functionality coming in ES6 and beyond, and it wasn\u2019t clear how CoffeeScript users would be able to take advantage of it. For example, CoffeeScript adopted for..of loops to iterate over the properties of an object. Meanwhile, ES6 introduced its own for..of loops as a way to loop through iterable objects. If CoffeeScript wants to support new functionality with similar syntax like this, it has two choices: break existing CoffeeScript code, or diverge from JavaScript more and more over time. Because JavaScript is the lingua franca of the web, and the web is everywhere, it is a programming language subject to enormous compatibility constraints. The smallest language change can potentially render millions of sites inoperable. I have witnessed the intense amount of thought and care TC39 members devote to figuring out how to introduce modern language features in a way that is completely backwards-compatible. It involves dumping out all of the existing features and syntax on a table, and painstakingly moving them around until a compatible path can be traced through. Unfortunately, this heroic effort only helps JavaScript, not \u201calt-JavaScript.\u201d At the end of the day, transpiled languages suffer from one of two problems: But not TypeScript. TypeScript is different. TypeScript is different because of how radically constrained it is. Most transpiled languages exist because they want to correct some perceived deficiencies in JavaScript. It\u2019s hard to quantify, but you can feel the respect that the TypeScript team has for JavaScript. They\u2019re not trying to rescue an inherently flawed language; instead, they\u2019re trying to help a language they love reach new heights. I love TypeScript because the delta between it and JavaScript is so small. In fact, you can take any JavaScript file, change the extension to\u00a0.ts, and boom, you\u2019ve got a valid TypeScript file. Because TypeScript is a superset of JavaScript, you\u2019ve actually been writing TypeScript this whole time. From there, you can incrementally add type checking only where you think it\u2019s necessary. It\u2019s easy for people to have a visceral negative reaction to TypeScript. Let\u2019s be frank: a lot of TypeScript examples are nearly indistinguishable from Java. But two points: JavaScript + Types = TypeScript For people who haven\u2019t used TypeScript, it\u2019s easy to imagine that it might be a bunch of weird, complicated new stuff on top of JavaScript, in addition to types. In reality, TypeScript is just JavaScript plus the smallest possible set of syntax additions required to let you incrementally typecheck your code. What\u2019s incredible about the TypeScript compiler is that it doesn\u2019t transpile code so much as just strip out type annotations. Debugging is straightforward because each line of TypeScript corresponds to the same line of JavaScript, just without the types. Here\u2019s an example TypeScript file, and the resulting compiled JavaScript (targeting ES2017): As you can see, we\u2019re using cutting-edge ES2017 features like async functions, and the syntax is exactly the same across both. The only difference in the TypeScript version is that we declare the fields on the Person class, as well as the type of the arguments to the constructor; these simply disappear in the JavaScript output. And even these simple annotations quickly begin to pay dividends. For example, using a TypeScript-enabled editor like VS Code gives us detailed information about class properties, just by hovering our mouse over them: \u201cBut I Still Don\u2019t Want to Use TypeScript!\u201d And that\u2019s totally cool! Glimmer is a library, first and foremost, for writing JavaScript apps. If you don\u2019t want to use TypeScript, you should have the freedom not to. \u201cThat\u2019s what Angular said and look how that turned\u00a0out.\u201d OK, I guess this is maybe the elephant in the room. A lot of people\u2019s first exposure to TypeScript was Angular 2. Looking at the Angular website, it\u2019s easy to get the sense that using TypeScript means JavaScript becomes a de facto second-class citizen. For example, here\u2019s an Angular component in TypeScript: Here\u2019s the same thing in ES6 JavaScript: As you can see, the JavaScript version is quite a bit longer than the TypeScript version. So why wouldn\u2019t Glimmer suffer the same fate? The primary reason is that Angular relies on an experimental TypeScript feature that emits type information in the compiled JavaScript (i.e., emitDecoratorMetadata). Dependency injection is front and center in Angular, so they (very rationally) decided to use the types you\u2019d write anyway to power the DI system. I actually think this is a cool example of improving developer ergonomics in Angular by using existing type information, but it does have the unfortunate effect of requiring different, often awkward APIs for people who want to use JavaScript. Glimmer goes in the other direction. We like that TypeScript is just JavaScript, so the APIs you use in both languages are exactly the same. Because Glimmer is written in TypeScript, you get great autocompletion and type checking out of the box, but there\u2019s no requirement to use TypeScript, and there\u2019s no alternate set of APIs for JavaScript. After having used TypeScript for nearly a year, I have to confess: I never want to start a new project without it again. Refactors that used to take weeks take days, sometimes less. And because refactoring is so much easier, cleanup that would never have happened becomes\u2026 almost painless. In literally every case, converting a project from JavaScript to TypeScript has identified at least one bug. Because I\u2019m now aware of the kinds of bugs TypeScript catches automatically, writing code without it feels like walking a tight rope without a net. Most of all, I continue to be impressed by the professionalism of the TypeScript team. In an ecosystem that can feel built on a house of unmaintained cards, TypeScript\u2019s drumbeat of constant, iterative improvement is refreshing. TypeScript is exploding in popularity and I think it will continue to only get more popular. As I finish writing this post, Felix Rieseberg\u2019s post on using TypeScript at Slack is on the front page of Hacker News. I suspect that most people who try TypeScript will end up liking it. At the end of the day, though, JavaScript is the language of the web. It\u2019s our job to give you a library that feels great whatever you choose. That\u2019s why we design our APIs for JavaScript first, and thanks to TypeScript\u2019s love for JavaScript, it couldn\u2019t be easier. ", "author": "Tom Dale", "parent": ""}