{"name": "2131", "title": "An enhanced GraphQL developer experience with TypeScript", "sentences": [{"1c66": "An enhanced GraphQL developer experience with TypeScript"}, {"52b6": "Develop faster and better with the GraphQL type\u00a0system"}, {"dd07": "Guest post by Robin Ricard (Github, Twitter, Website), community contributor to the Apollo project."}, {"98eb": "A few months ago, Sashko Stubailo wrote an excellent article about the benefits of static GraphQL queries. After seeing that article, I immediately wanted to get that great development experience he was talking about in my own projects. Unfortunately, all of this tooling was only available for Swift and Xcode, until now\u2026"}, {"dfd2": "Today, I\u2019m happy to announce that a complete GraphQL developer experience for Typescript is available! (with Flow coming soon\u2026)"}, {"cf7c": "Automatic query and fragments loading"}, {"d74d": "In my latest job, I worked on a large GraphQL project where we had a lot of fragments. This rapidly became a pain to work with. We had many issues to correctly import those fragments in files scattered around the project. This made most of our fragment resolution not static at all. graphql-document-collector has been created to solve this problem: instead of storing queries and fragments in js files, we can now store them in static graphql files around the project. The collector will gather all documents (fragments, queries, mutations, etc) found in the project and put them in a single file containing all of the project documents with their fragments auto-resolved!"}, {"25a5": "This is usually done using a single command:"}, {"10f1": "graphql-document-collector '**/*.graphql' > documents.json"}, {"7e60": "This JSON file contains all of the documents you may want to use, let\u2019s see how I would use that in my project:"}, {"bcc4": "That\u2019s pretty straightforward; you don\u2019t even need to use the gql tag. In this case, Feed.graphql can use fragments located in a file named fragments/Item.graphql: the collector will handle that for us. The only limitation is that you can't have two fragments with the same name in your project."}, {"be50": "Automatic type annotation generation for TypeScript"}, {"19e6": "Another issue we had was in guaranteeing the data we were accessing in our UI was corresponding to the query we just had fetched, even when we changed our queries in our codebase. Alongside our operations and fragments we added type annotations corresponding to the graphql document. Unfortunately, the annotations and the queries stopped matching each other over time. Either we forgot to report a field removal or we just misinterpreted the type from the schema, for instance, making something non-nullable that should be nullable."}, {"4526": "Since GraphQL is a completely typed language and our queries are now completely static, we can now generate those annotations automatically! In order to do that in a TypeScript project, I added to apollo-codegen a generator that converts GraphQL documents and schema to typescript interfaces."}, {"156b": "Let\u2019s take this simple query with a fragment:"}, {"0011": "With the following schema:"}, {"5d4c": "With those, using apollo-codegen for TypeScript, we can generate this annotations file:"}, {"a632": "All you have to do is pull your schema with an introspection query from your server:"}, {"46bf": "apollo-codegen download http://localhost:8080/graphql \\  --output schema.json"}, {"b364": "Once you have the schema, generate the annotations:"}, {"9242": "apollo-codegen generate **/*.graphql \\  --schema schema.json \\  --target ts \\  --output schema.ts"}, {"d216": "You can now import and use those annotations in your codebase to ensure your GraphQL results are used safely. For instance, now, if I try to type this:"}, {"2cdd": "I\u2019ll can see errors telling me I made some mistakes."}, {"8ad2": "Create correct GraphQL documents from your\u00a0editor"}, {"e99b": "Since we just downloaded a schema.json, it's good to know we can use it to type check our GraphQL documents as well. Just use the GraphQL ESLint plugin against your\u00a0.graphql documents! (you will need to configure your editor to consider graphql files as javascript files.) You can then write correct queries from the start without having to type them in GraphiQL since ESLint will show you errors directly:"}, {"2197": "Enough with Jar Jar!"}, {"9581": "Wrapping up!"}, {"c87b": "As you can see, your development experience can be improved using static GraphQL documents. For now, though, all of this requires some important setup work that can be daunting at first. We\u2019ll work on streamlining this process soon. In the meantime, you can always try our sample repository with all of the tooling you need to try out those features: typed-graphql-client-example. You should try to open it with VSCode to get the best out of the type system."}, {"1c1d": "Have fun developing awesome GraphQL apps!"}], "child": "2131_1\t2131_2\t2131_3\t2131_4\t2131_5\t2131_6\t2131_72131_1\t2131_2\t2131_3\t2131_4\t2131_5\t2131_6\t2131_72131_1\t2131_2\t2131_3\t2131_4\t2131_5\t2131_6\t2131_7", "timestamp": "Dec 8, 2016", "content": "An enhanced GraphQL developer experience with TypeScript Develop faster and better with the GraphQL type\u00a0system Guest post by Robin Ricard (Github, Twitter, Website), community contributor to the Apollo project. A few months ago, Sashko Stubailo wrote an excellent article about the benefits of static GraphQL queries. After seeing that article, I immediately wanted to get that great development experience he was talking about in my own projects. Unfortunately, all of this tooling was only available for Swift and Xcode, until now\u2026 Today, I\u2019m happy to announce that a complete GraphQL developer experience for Typescript is available! (with Flow coming soon\u2026) Automatic query and fragments loading In my latest job, I worked on a large GraphQL project where we had a lot of fragments. This rapidly became a pain to work with. We had many issues to correctly import those fragments in files scattered around the project. This made most of our fragment resolution not static at all. graphql-document-collector has been created to solve this problem: instead of storing queries and fragments in js files, we can now store them in static graphql files around the project. The collector will gather all documents (fragments, queries, mutations, etc) found in the project and put them in a single file containing all of the project documents with their fragments auto-resolved! This is usually done using a single command: graphql-document-collector '**/*.graphql' > documents.json This JSON file contains all of the documents you may want to use, let\u2019s see how I would use that in my project: That\u2019s pretty straightforward; you don\u2019t even need to use the gql tag. In this case, Feed.graphql can use fragments located in a file named fragments/Item.graphql: the collector will handle that for us. The only limitation is that you can't have two fragments with the same name in your project. Automatic type annotation generation for TypeScript Another issue we had was in guaranteeing the data we were accessing in our UI was corresponding to the query we just had fetched, even when we changed our queries in our codebase. Alongside our operations and fragments we added type annotations corresponding to the graphql document. Unfortunately, the annotations and the queries stopped matching each other over time. Either we forgot to report a field removal or we just misinterpreted the type from the schema, for instance, making something non-nullable that should be nullable. Since GraphQL is a completely typed language and our queries are now completely static, we can now generate those annotations automatically! In order to do that in a TypeScript project, I added to apollo-codegen a generator that converts GraphQL documents and schema to typescript interfaces. Let\u2019s take this simple query with a fragment: With the following schema: With those, using apollo-codegen for TypeScript, we can generate this annotations file: All you have to do is pull your schema with an introspection query from your server: apollo-codegen download http://localhost:8080/graphql \\  --output schema.json Once you have the schema, generate the annotations: apollo-codegen generate **/*.graphql \\  --schema schema.json \\  --target ts \\  --output schema.ts You can now import and use those annotations in your codebase to ensure your GraphQL results are used safely. For instance, now, if I try to type this: I\u2019ll can see errors telling me I made some mistakes. Create correct GraphQL documents from your\u00a0editor Since we just downloaded a schema.json, it's good to know we can use it to type check our GraphQL documents as well. Just use the GraphQL ESLint plugin against your\u00a0.graphql documents! (you will need to configure your editor to consider graphql files as javascript files.) You can then write correct queries from the start without having to type them in GraphiQL since ESLint will show you errors directly: Enough with Jar Jar! Wrapping up! As you can see, your development experience can be improved using static GraphQL documents. For now, though, all of this requires some important setup work that can be daunting at first. We\u2019ll work on streamlining this process soon. In the meantime, you can always try our sample repository with all of the tooling you need to try out those features: typed-graphql-client-example. You should try to open it with VSCode to get the best out of the type system. Have fun developing awesome GraphQL apps! ", "author": "Robin Ricard", "parent": ""}