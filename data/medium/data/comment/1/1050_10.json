{"parent": "1050", "title": "", "id": "ccbd38389809", "name": "1050_10", "content": "I think it\u2019s much more about maintainability than about us old-schoolers being stuck in our ways. As you mentioned, part of the issue is that there are so many frameworks and (even within something like node) so many packages to solve the same problem, and, unless we\u2019re on the frontlines solving the exact problem the framework is designed to solve, we\u2019ll have no idea which one will become the \u2018standard\u2019 later. Imagine yourself 3 years after you\u2019ve picked a framework and some packages for it. You run some update commands, run your usual tests, and something is broken. At this point, there\u2019s a chance that the framework you chose simply updated an API call or flag somewhere, and you need to do a handful of \u2018replace\u2019 statements and you\u2019re fine. This is the best-case, if you won framework bingo. Worst-case, you suddenly delve through and see your framework-of-choice hasn\u2019t been maintained for 3 years, but just kept on working because the underlying standards remained the same. Some new web standards are out now, and you\u2019re the only person using this framework in this way, so you either have to fix it yourself, or switch to whatever the more likely standard is now. Either way, it\u2019s a bit of a project, and probably not one you can afford to do. We\u2019ve all had an experience like that, but with the instability of the JS ecosystem, the chances of this happening literally every update cycle is really high. It\u2019s great for new sites and prototyping, and I\u2019m very reluctantly learning React because I see some convergence happening with it, but I think the maintenance concerns are still too high for putting it too prominently in your critical path (unless, again, your critical path is to be on the frontlines of JS) ", "creatorid": "a2edc2094624", "timestamp": 1490354358059, "child": "", "username": "nimishgautam"}